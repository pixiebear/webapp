{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { BaseSignerWalletAdapter, WalletConnectionError, WalletDisconnectionError, WalletError, WalletKeypairError, WalletNotConnectedError, WalletSignTransactionError, WalletWindowBlockedError, WalletWindowClosedError } from '@solana/wallet-adapter-base';\nimport { Keypair } from '@solana/web3.js';\nimport OpenLogin, { OPENLOGIN_NETWORK } from '@toruslabs/openlogin';\nimport { getED25519Key } from '@toruslabs/openlogin-ed25519';\nexport class TorusWalletAdapter extends BaseSignerWalletAdapter {\n  constructor(config) {\n    super();\n    this._options = Object.assign({\n      uxMode: 'popup',\n      network: OPENLOGIN_NETWORK.MAINNET\n    }, config.options);\n    this._connecting = false;\n    this._openLogin = null;\n    this._keypair = null;\n  }\n\n  get publicKey() {\n    var _a;\n\n    return ((_a = this._keypair) === null || _a === void 0 ? void 0 : _a.publicKey) || null;\n  }\n\n  get ready() {\n    return typeof window !== 'undefined';\n  }\n\n  get connecting() {\n    return this._connecting;\n  }\n\n  get connected() {\n    return !!this._keypair;\n  }\n\n  connect() {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (this.connected || this.connecting) return;\n        this._connecting = true;\n        let openLogin;\n        let privateKey;\n\n        try {\n          openLogin = new OpenLogin(this._options);\n          yield openLogin.init();\n          privateKey = openLogin.privKey;\n\n          if (!privateKey) {\n            let listener;\n\n            try {\n              privateKey = yield new Promise((resolve, reject) => {\n                listener = _ref => {\n                  let {\n                    reason\n                  } = _ref;\n\n                  switch (reason === null || reason === void 0 ? void 0 : reason.message.toLowerCase()) {\n                    case 'user closed popup':\n                      reason = new WalletWindowClosedError(reason.message, reason);\n                      break;\n\n                    case 'unable to open window':\n                      reason = new WalletWindowBlockedError(reason.message, reason);\n                      break;\n                  }\n\n                  reject(reason);\n                };\n\n                window.addEventListener('unhandledrejection', listener);\n                openLogin.login().then( // HACK: result.privKey is not padded to 64 bytes, use provider.privKey\n                result => resolve(openLogin.privKey), reason => listener({\n                  reason\n                }));\n              });\n            } finally {\n              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n              window.removeEventListener('unhandledrejection', listener);\n            }\n          }\n        } catch (error) {\n          if (error instanceof WalletError) throw error;\n          throw new WalletConnectionError(error === null || error === void 0 ? void 0 : error.message, error);\n        }\n\n        let keypair;\n\n        try {\n          keypair = Keypair.fromSecretKey(getED25519Key(privateKey).sk);\n        } catch (error) {\n          throw new WalletKeypairError(error === null || error === void 0 ? void 0 : error.message, error);\n        }\n\n        this._openLogin = openLogin;\n        this._keypair = keypair;\n        this.emit('connect');\n      } catch (error) {\n        this.emit('error', error);\n        throw error;\n      } finally {\n        this._connecting = false;\n      }\n    });\n  }\n\n  disconnect() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const openLogin = this._openLogin;\n\n      if (openLogin) {\n        this._openLogin = null;\n        this._keypair = null;\n\n        try {\n          yield openLogin.logout();\n          yield openLogin._cleanup();\n        } catch (error) {\n          this.emit('error', new WalletDisconnectionError(error === null || error === void 0 ? void 0 : error.message, error));\n        }\n      }\n\n      this.emit('disconnect');\n    });\n  }\n\n  signTransaction(transaction) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const keypair = this._keypair;\n        if (!keypair) throw new WalletNotConnectedError();\n\n        try {\n          transaction.partialSign(keypair);\n        } catch (error) {\n          throw new WalletSignTransactionError(error === null || error === void 0 ? void 0 : error.message, error);\n        }\n\n        return transaction;\n      } catch (error) {\n        this.emit('error', error);\n        throw error;\n      }\n    });\n  }\n\n  signAllTransactions(transactions) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const keypair = this._keypair;\n        if (!keypair) throw new WalletNotConnectedError();\n\n        try {\n          for (const transaction of transactions) {\n            transaction.partialSign(keypair);\n          }\n        } catch (error) {\n          throw new WalletSignTransactionError(error === null || error === void 0 ? void 0 : error.message, error);\n        }\n\n        return transactions;\n      } catch (error) {\n        this.emit('error', error);\n        throw error;\n      }\n    });\n  }\n\n}","map":{"version":3,"sources":["../src/adapter.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { BaseSignerWalletAdapter, WalletConnectionError, WalletDisconnectionError, WalletError, WalletKeypairError, WalletNotConnectedError, WalletSignTransactionError, WalletWindowBlockedError, WalletWindowClosedError, } from '@solana/wallet-adapter-base';\nimport { Keypair } from '@solana/web3.js';\nimport OpenLogin, { OPENLOGIN_NETWORK } from '@toruslabs/openlogin';\nimport { getED25519Key } from '@toruslabs/openlogin-ed25519';\nexport class TorusWalletAdapter extends BaseSignerWalletAdapter {\n    constructor(config) {\n        super();\n        this._options = Object.assign({ uxMode: 'popup', network: OPENLOGIN_NETWORK.MAINNET }, config.options);\n        this._connecting = false;\n        this._openLogin = null;\n        this._keypair = null;\n    }\n    get publicKey() {\n        var _a;\n        return ((_a = this._keypair) === null || _a === void 0 ? void 0 : _a.publicKey) || null;\n    }\n    get ready() {\n        return typeof window !== 'undefined';\n    }\n    get connecting() {\n        return this._connecting;\n    }\n    get connected() {\n        return !!this._keypair;\n    }\n    connect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                if (this.connected || this.connecting)\n                    return;\n                this._connecting = true;\n                let openLogin;\n                let privateKey;\n                try {\n                    openLogin = new OpenLogin(this._options);\n                    yield openLogin.init();\n                    privateKey = openLogin.privKey;\n                    if (!privateKey) {\n                        let listener;\n                        try {\n                            privateKey = yield new Promise((resolve, reject) => {\n                                listener = ({ reason }) => {\n                                    switch (reason === null || reason === void 0 ? void 0 : reason.message.toLowerCase()) {\n                                        case 'user closed popup':\n                                            reason = new WalletWindowClosedError(reason.message, reason);\n                                            break;\n                                        case 'unable to open window':\n                                            reason = new WalletWindowBlockedError(reason.message, reason);\n                                            break;\n                                    }\n                                    reject(reason);\n                                };\n                                window.addEventListener('unhandledrejection', listener);\n                                openLogin.login().then(\n                                // HACK: result.privKey is not padded to 64 bytes, use provider.privKey\n                                (result) => resolve(openLogin.privKey), (reason) => listener({ reason }));\n                            });\n                        }\n                        finally {\n                            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                            window.removeEventListener('unhandledrejection', listener);\n                        }\n                    }\n                }\n                catch (error) {\n                    if (error instanceof WalletError)\n                        throw error;\n                    throw new WalletConnectionError(error === null || error === void 0 ? void 0 : error.message, error);\n                }\n                let keypair;\n                try {\n                    keypair = Keypair.fromSecretKey(getED25519Key(privateKey).sk);\n                }\n                catch (error) {\n                    throw new WalletKeypairError(error === null || error === void 0 ? void 0 : error.message, error);\n                }\n                this._openLogin = openLogin;\n                this._keypair = keypair;\n                this.emit('connect');\n            }\n            catch (error) {\n                this.emit('error', error);\n                throw error;\n            }\n            finally {\n                this._connecting = false;\n            }\n        });\n    }\n    disconnect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const openLogin = this._openLogin;\n            if (openLogin) {\n                this._openLogin = null;\n                this._keypair = null;\n                try {\n                    yield openLogin.logout();\n                    yield openLogin._cleanup();\n                }\n                catch (error) {\n                    this.emit('error', new WalletDisconnectionError(error === null || error === void 0 ? void 0 : error.message, error));\n                }\n            }\n            this.emit('disconnect');\n        });\n    }\n    signTransaction(transaction) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const keypair = this._keypair;\n                if (!keypair)\n                    throw new WalletNotConnectedError();\n                try {\n                    transaction.partialSign(keypair);\n                }\n                catch (error) {\n                    throw new WalletSignTransactionError(error === null || error === void 0 ? void 0 : error.message, error);\n                }\n                return transaction;\n            }\n            catch (error) {\n                this.emit('error', error);\n                throw error;\n            }\n        });\n    }\n    signAllTransactions(transactions) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const keypair = this._keypair;\n                if (!keypair)\n                    throw new WalletNotConnectedError();\n                try {\n                    for (const transaction of transactions) {\n                        transaction.partialSign(keypair);\n                    }\n                }\n                catch (error) {\n                    throw new WalletSignTransactionError(error === null || error === void 0 ? void 0 : error.message, error);\n                }\n                return transactions;\n            }\n            catch (error) {\n                this.emit('error', error);\n                throw error;\n            }\n        });\n    }\n}\n//# sourceMappingURL=adapter.js.map"]},"metadata":{},"sourceType":"module"}