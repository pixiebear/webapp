{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AssignablePublicKey = void 0;\n\nconst solanaBorsh_1 = require(\"./solanaBorsh\");\n\nconst web3_js_1 = require(\"@solana/web3.js\");\n/**\n * A Borsh-compatible public key object\n *\n * The pattern for these objects is to have their properties dynamically\n * assigned by borsh.decode, as opposed to via a constructor.\n *\n * The imperative assignment operator (!) is used to avoid Typescript\n * complaining about the above.\n */\n\n\nclass AssignablePublicKey extends solanaBorsh_1.Assignable {\n  toPublicKey() {\n    return new web3_js_1.PublicKey(this.bytes);\n  }\n\n  toString() {\n    return this.toPublicKey().toBase58();\n  }\n\n  static parse(pubkey) {\n    return AssignablePublicKey.fromPublicKey(new web3_js_1.PublicKey(pubkey));\n  }\n\n  static fromPublicKey(publicKey) {\n    return new AssignablePublicKey({\n      bytes: Uint8Array.from(publicKey.toBuffer())\n    });\n  }\n\n  static empty() {\n    const bytes = new Array(32);\n    bytes.fill(0);\n    return new AssignablePublicKey({\n      bytes\n    });\n  }\n\n}\n\nexports.AssignablePublicKey = AssignablePublicKey;\nsolanaBorsh_1.SCHEMA.set(AssignablePublicKey, {\n  kind: \"struct\",\n  fields: [[\"bytes\", [32]]]\n});","map":{"version":3,"sources":["../../src/lib/AssignablePublicKey.ts"],"names":[],"mappings":";;;;;;;AAAA,MAAA,aAAA,GAAA,OAAA,CAAA,eAAA,CAAA;;AACA,MAAA,SAAA,GAAA,OAAA,CAAA,iBAAA,CAAA;AAEA;;;;;;;;AAQG;;;AACH,MAAa,mBAAb,SAAyC,aAAA,CAAA,UAAzC,CAAmD;EAIjD,WAAW,GAAA;IACT,OAAO,IAAI,SAAA,CAAA,SAAJ,CAAc,KAAK,KAAnB,CAAP;EACD;;EAED,QAAQ,GAAA;IACN,OAAO,KAAK,WAAL,GAAmB,QAAnB,EAAP;EACD;;EAEW,OAAL,KAAK,CAAC,MAAD,EAAe;IACzB,OAAO,mBAAmB,CAAC,aAApB,CAAkC,IAAI,SAAA,CAAA,SAAJ,CAAc,MAAd,CAAlC,CAAP;EACD;;EAEmB,OAAb,aAAa,CAAC,SAAD,EAAqB;IACvC,OAAO,IAAI,mBAAJ,CAAwB;MAC7B,KAAK,EAAE,UAAU,CAAC,IAAX,CAAgB,SAAS,CAAC,QAAV,EAAhB;IADsB,CAAxB,CAAP;EAGD;;EAEW,OAAL,KAAK,GAAA;IACV,MAAM,KAAK,GAAG,IAAI,KAAJ,CAAU,EAAV,CAAd;IACA,KAAK,CAAC,IAAN,CAAW,CAAX;IACA,OAAO,IAAI,mBAAJ,CAAwB;MAAE;IAAF,CAAxB,CAAP;EACD;;AA1BgD;;AAAnD,OAAA,CAAA,mBAAA,GAAA,mBAAA;AA6BA,aAAA,CAAA,MAAA,CAAO,GAAP,CAAW,mBAAX,EAAgC;EAC9B,IAAI,EAAE,QADwB;EAE9B,MAAM,EAAE,CAAC,CAAC,OAAD,EAAU,CAAC,EAAD,CAAV,CAAD;AAFsB,CAAhC","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AssignablePublicKey = void 0;\nconst solanaBorsh_1 = require(\"./solanaBorsh\");\nconst web3_js_1 = require(\"@solana/web3.js\");\n/**\n * A Borsh-compatible public key object\n *\n * The pattern for these objects is to have their properties dynamically\n * assigned by borsh.decode, as opposed to via a constructor.\n *\n * The imperative assignment operator (!) is used to avoid Typescript\n * complaining about the above.\n */\nclass AssignablePublicKey extends solanaBorsh_1.Assignable {\n    toPublicKey() {\n        return new web3_js_1.PublicKey(this.bytes);\n    }\n    toString() {\n        return this.toPublicKey().toBase58();\n    }\n    static parse(pubkey) {\n        return AssignablePublicKey.fromPublicKey(new web3_js_1.PublicKey(pubkey));\n    }\n    static fromPublicKey(publicKey) {\n        return new AssignablePublicKey({\n            bytes: Uint8Array.from(publicKey.toBuffer()),\n        });\n    }\n    static empty() {\n        const bytes = new Array(32);\n        bytes.fill(0);\n        return new AssignablePublicKey({ bytes });\n    }\n}\nexports.AssignablePublicKey = AssignablePublicKey;\nsolanaBorsh_1.SCHEMA.set(AssignablePublicKey, {\n    kind: \"struct\",\n    fields: [[\"bytes\", [32]]],\n});\n//# sourceMappingURL=AssignablePublicKey.js.map"]},"metadata":{},"sourceType":"script"}