{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/nikola/Sites/candy-machine/candy-machine-ui/node_modules/@babel/runtime/regenerator/index.js\");\n\nvar _asyncToGenerator = require(\"/Users/nikola/Sites/candy-machine/candy-machine-ui/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.reducer = void 0;\n\nvar react_1 = require(\"react\");\n\nvar types_1 = require(\"../types\");\n\nvar logger_1 = __importDefault(require(\"../logger\"));\n\nvar useWalletHooks_1 = __importDefault(require(\"./useWalletHooks\"));\n\nvar reducer = function reducer(state, action) {\n  switch (action.type) {\n    case 'tokenOnChainNotFound':\n      return Object.assign(Object.assign({}, state), {\n        gatewayStatus: types_1.GatewayStatus.NOT_REQUESTED\n      });\n\n    case 'tokenOnChainError':\n      return Object.assign(Object.assign({}, state), {\n        gatewayStatus: types_1.GatewayStatus.ERROR\n      });\n\n    default:\n      return state;\n  }\n};\n\nexports.reducer = reducer;\n\nvar useChain = function useChain(_ref, state, dispatch) {\n  var wallet = _ref.wallet,\n      chainImplementation = _ref.chainImplementation,\n      networkConfig = _ref.networkConfig;\n\n  var _ref2 = (0, useWalletHooks_1.default)(wallet, state, dispatch),\n      expectWalletConnected = _ref2.expectWalletConnected;\n\n  var gatekeeperRecordState = state.gatekeeperRecordState,\n      gatewayToken = state.gatewayToken;\n\n  var logDebug = function logDebug(message) {\n    var obj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return logger_1.default.debug(\"[useChain] \".concat(message), obj);\n  };\n\n  var logError = function logError(message) {\n    var obj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return logger_1.default.error(\"[useChain] \".concat(message), obj);\n  };\n\n  var removeOnChainListener = function removeOnChainListener(listernerId) {\n    try {\n      logDebug('Removing onChainListener with id: ', listernerId);\n      chainImplementation.removeOnGatewayTokenChangeListener(listernerId);\n    } catch (error) {\n      logError('Error removing on chain listener', error);\n    }\n  };\n  /**\n   * listen to the blockchain for any token changes and update local state if there are\n   */\n\n\n  var addTokenChangeListeners = // eslint-disable-next-line @typescript-eslint/no-shadow\n  function addTokenChangeListeners(gatewayToken) {\n    var tokenChangeCallback = function tokenChangeCallback(token) {\n      dispatch({\n        type: 'tokenChange',\n        token: token\n      });\n      dispatch({\n        type: 'civicPass_check_token_status',\n        token: token\n      });\n    };\n\n    var listernerId = chainImplementation.addOnGatewayTokenChangeListener(gatewayToken, tokenChangeCallback);\n    logDebug('Adding onChainListener with id: ', listernerId);\n    return listernerId;\n  };\n\n  (0, react_1.useEffect)(function () {\n    var listernerId;\n\n    if (gatewayToken) {\n      listernerId = addTokenChangeListeners(gatewayToken);\n    }\n\n    return function () {\n      if (listernerId) {\n        removeOnChainListener(listernerId);\n      }\n    };\n  }, [gatekeeperRecordState, gatewayToken]);\n  /**\n   * use the on-chain lookup utility findGatewayToken to retrieve a token from the chain\n   * when a token is found, set up listeners to monitor any on-chain changes\n   */\n\n  var dispatchTokenFromChain = /*#__PURE__*/function () {\n    var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n      var connectedWallet, token, shouldDispatchTokenFromChain;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              connectedWallet = expectWalletConnected();\n              _context.prev = 1;\n              logDebug('Fetching token from chain');\n              _context.next = 5;\n              return chainImplementation.findGatewayToken();\n\n            case 5:\n              token = _context.sent;\n\n              if (token) {\n                _context.next = 9;\n                break;\n              }\n\n              dispatch({\n                type: 'tokenOnChainNotFound'\n              });\n              return _context.abrupt(\"return\");\n\n            case 9:\n              logDebug('Token found', token);\n              dispatch({\n                type: 'tokenChange',\n                token: token\n              }); // Determine if we should show the civicPass dialog when we have a gateway token\n\n              shouldDispatchTokenFromChain = gatekeeperRecordState && [types_1.GatekeeperRecordState.ISSUED_EXPIRED, types_1.GatekeeperRecordState.ISSUED_EXPIRY_APPROACHING, types_1.GatekeeperRecordState.ISSUED_LOCATION_NOT_SUPPORTED, types_1.GatekeeperRecordState.ISSUED_VPN_NOT_SUPPORTED].includes(gatekeeperRecordState);\n\n              if (shouldDispatchTokenFromChain) {\n                _context.next = 14;\n                break;\n              }\n\n              return _context.abrupt(\"return\");\n\n            case 14:\n              dispatch({\n                type: 'civicPass_check_token_status',\n                token: token\n              });\n              _context.next = 22;\n              break;\n\n            case 17:\n              _context.prev = 17;\n              _context.t0 = _context[\"catch\"](1);\n              logError(\"Error getting token from chain for \".concat(connectedWallet.publicKey), _context.t0);\n              dispatch({\n                type: 'tokenOnChainError'\n              });\n              throw _context.t0;\n\n            case 22:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[1, 17]]);\n    }));\n\n    return function dispatchTokenFromChain() {\n      return _ref3.apply(this, arguments);\n    };\n  }();\n  /**\n   * Determine if we should fetch a token from chain based on the gatekeeper record state\n   */\n\n\n  (0, react_1.useEffect)(function () {\n    var shouldDispatchTokenFromChain = gatekeeperRecordState && [types_1.GatekeeperRecordState.ISSUED, types_1.GatekeeperRecordState.ISSUED_EXPIRED, types_1.GatekeeperRecordState.ISSUED_EXPIRY_APPROACHING, types_1.GatekeeperRecordState.REQUESTED, types_1.GatekeeperRecordState.ISSUED_LOCATION_NOT_SUPPORTED, types_1.GatekeeperRecordState.ISSUED_VPN_NOT_SUPPORTED, types_1.GatekeeperRecordState.SERVER_FAILURE].includes(gatekeeperRecordState);\n    if (!shouldDispatchTokenFromChain) return;\n    dispatchTokenFromChain();\n  }, [gatekeeperRecordState, chainImplementation]);\n  /**\n   * Check token on chain if checking the record status is not required\n   * This will then run when the component is mounted instead of after the record has been fetched\n   */\n\n  (0, react_1.useEffect)(function () {\n    if (networkConfig.requiresGatekeeperRecordStatusCheck) return;\n    dispatchTokenFromChain();\n  }, [networkConfig.requiresGatekeeperRecordStatusCheck, chainImplementation]);\n  return {\n    addTokenChangeListeners: addTokenChangeListeners,\n    dispatchTokenFromChain: dispatchTokenFromChain\n  };\n};\n\nexports.default = useChain;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","reducer","react_1","require","types_1","logger_1","useWalletHooks_1","state","action","type","assign","gatewayStatus","GatewayStatus","NOT_REQUESTED","ERROR","useChain","dispatch","wallet","chainImplementation","networkConfig","default","expectWalletConnected","gatekeeperRecordState","gatewayToken","logDebug","message","obj","debug","logError","error","removeOnChainListener","listernerId","removeOnGatewayTokenChangeListener","addTokenChangeListeners","tokenChangeCallback","token","addOnGatewayTokenChangeListener","useEffect","dispatchTokenFromChain","connectedWallet","findGatewayToken","shouldDispatchTokenFromChain","GatekeeperRecordState","ISSUED_EXPIRED","ISSUED_EXPIRY_APPROACHING","ISSUED_LOCATION_NOT_SUPPORTED","ISSUED_VPN_NOT_SUPPORTED","includes","publicKey","ISSUED","REQUESTED","SERVER_FAILURE","requiresGatekeeperRecordStatusCheck"],"sources":["/Users/nikola/Sites/candy-machine/candy-machine-ui/node_modules/@civic/solana-gateway-react/dist/esm/useHooks/useChain.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.reducer = void 0;\nconst react_1 = require(\"react\");\nconst types_1 = require(\"../types\");\nconst logger_1 = __importDefault(require(\"../logger\"));\nconst useWalletHooks_1 = __importDefault(require(\"./useWalletHooks\"));\nconst reducer = (state, action) => {\n    switch (action.type) {\n        case 'tokenOnChainNotFound':\n            return Object.assign(Object.assign({}, state), { gatewayStatus: types_1.GatewayStatus.NOT_REQUESTED });\n        case 'tokenOnChainError':\n            return Object.assign(Object.assign({}, state), { gatewayStatus: types_1.GatewayStatus.ERROR });\n        default:\n            return state;\n    }\n};\nexports.reducer = reducer;\nconst useChain = ({ wallet, chainImplementation, networkConfig, }, state, dispatch) => {\n    const { expectWalletConnected } = (0, useWalletHooks_1.default)(wallet, state, dispatch);\n    const { gatekeeperRecordState, gatewayToken } = state;\n    const logDebug = (message, obj = null) => logger_1.default.debug(`[useChain] ${message}`, obj);\n    const logError = (message, obj = null) => logger_1.default.error(`[useChain] ${message}`, obj);\n    const removeOnChainListener = (listernerId) => {\n        try {\n            logDebug('Removing onChainListener with id: ', listernerId);\n            chainImplementation.removeOnGatewayTokenChangeListener(listernerId);\n        }\n        catch (error) {\n            logError('Error removing on chain listener', error);\n        }\n    };\n    /**\n     * listen to the blockchain for any token changes and update local state if there are\n     */\n    const addTokenChangeListeners = \n    // eslint-disable-next-line @typescript-eslint/no-shadow\n    (gatewayToken) => {\n        const tokenChangeCallback = (token) => {\n            dispatch({ type: 'tokenChange', token });\n            dispatch({ type: 'civicPass_check_token_status', token });\n        };\n        const listernerId = chainImplementation.addOnGatewayTokenChangeListener(gatewayToken, tokenChangeCallback);\n        logDebug('Adding onChainListener with id: ', listernerId);\n        return listernerId;\n    };\n    (0, react_1.useEffect)(() => {\n        let listernerId;\n        if (gatewayToken) {\n            listernerId = addTokenChangeListeners(gatewayToken);\n        }\n        return () => {\n            if (listernerId) {\n                removeOnChainListener(listernerId);\n            }\n        };\n    }, [gatekeeperRecordState, gatewayToken]);\n    /**\n     * use the on-chain lookup utility findGatewayToken to retrieve a token from the chain\n     * when a token is found, set up listeners to monitor any on-chain changes\n     */\n    const dispatchTokenFromChain = async () => {\n        const connectedWallet = expectWalletConnected();\n        try {\n            logDebug('Fetching token from chain');\n            const token = await chainImplementation.findGatewayToken();\n            if (!token) {\n                dispatch({ type: 'tokenOnChainNotFound' });\n                return;\n            }\n            logDebug('Token found', token);\n            dispatch({ type: 'tokenChange', token });\n            // Determine if we should show the civicPass dialog when we have a gateway token\n            const shouldDispatchTokenFromChain = gatekeeperRecordState &&\n                [\n                    types_1.GatekeeperRecordState.ISSUED_EXPIRED,\n                    types_1.GatekeeperRecordState.ISSUED_EXPIRY_APPROACHING,\n                    types_1.GatekeeperRecordState.ISSUED_LOCATION_NOT_SUPPORTED,\n                    types_1.GatekeeperRecordState.ISSUED_VPN_NOT_SUPPORTED,\n                ].includes(gatekeeperRecordState);\n            if (!shouldDispatchTokenFromChain)\n                return;\n            dispatch({ type: 'civicPass_check_token_status', token });\n        }\n        catch (error) {\n            logError(`Error getting token from chain for ${connectedWallet.publicKey}`, error);\n            dispatch({ type: 'tokenOnChainError' });\n            throw error;\n        }\n    };\n    /**\n     * Determine if we should fetch a token from chain based on the gatekeeper record state\n     */\n    (0, react_1.useEffect)(() => {\n        const shouldDispatchTokenFromChain = gatekeeperRecordState &&\n            [\n                types_1.GatekeeperRecordState.ISSUED,\n                types_1.GatekeeperRecordState.ISSUED_EXPIRED,\n                types_1.GatekeeperRecordState.ISSUED_EXPIRY_APPROACHING,\n                types_1.GatekeeperRecordState.REQUESTED,\n                types_1.GatekeeperRecordState.ISSUED_LOCATION_NOT_SUPPORTED,\n                types_1.GatekeeperRecordState.ISSUED_VPN_NOT_SUPPORTED,\n                types_1.GatekeeperRecordState.SERVER_FAILURE,\n            ].includes(gatekeeperRecordState);\n        if (!shouldDispatchTokenFromChain)\n            return;\n        dispatchTokenFromChain();\n    }, [gatekeeperRecordState, chainImplementation]);\n    /**\n     * Check token on chain if checking the record status is not required\n     * This will then run when the component is mounted instead of after the record has been fetched\n     */\n    (0, react_1.useEffect)(() => {\n        if (networkConfig.requiresGatekeeperRecordStatusCheck)\n            return;\n        dispatchTokenFromChain();\n    }, [networkConfig.requiresGatekeeperRecordStatusCheck, chainImplementation]);\n    return {\n        addTokenChangeListeners,\n        dispatchTokenFromChain,\n    };\n};\nexports.default = useChain;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}