{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GatewayTokenActionCreatorImplementation = void 0;\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\nconst types_1 = require(\"../types\");\n\nconst logger_1 = __importDefault(require(\"../logger\"));\n\nconst utils_1 = require(\"./utils\");\n\nconst GatewayTokenActionCreatorImplementation = _ref => {\n  let {\n    wallet,\n    chainImplementation,\n    gatekeeperClient,\n    dispatch,\n    networkConfig\n  } = _ref;\n\n  const logDebug = function (message) {\n    let obj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return logger_1.default.debug(`[useChain] ${message}`, obj);\n  };\n\n  const logError = function (message) {\n    let obj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return logger_1.default.error(`[useChain] ${message}`, obj);\n  };\n\n  const isTokenCreated = code => code === 200;\n\n  const isTokenPending = code => code === 202 || code === 404;\n\n  const isFailure = code => !isTokenPending(code) && code >= 400;\n\n  const pollForActiveOnChainToken = async () => {\n    return (0, utils_1.pollUntilConditionMet)(chainImplementation.findGatewayToken, onChainToken => {\n      if (!onChainToken) return false; // keep polling\n\n      if (!onChainToken.expiryTime) return true;\n      if (onChainToken.state === types_1.State.ACTIVE) return true;\n      throw new Error('Token found but not ACTIVE');\n    }, networkConfig.pollChainIntervalMilliseconds, networkConfig.pollChainNumberRetries);\n  };\n\n  const waitForGatewayToken = async () => {\n    // poll the gatekeeper until we have a status for a created record\n    // if we don't get a created token, then we consider it a failure\n    try {\n      const token = await pollForActiveOnChainToken();\n      logDebug('Result from pollForActiveOnChainToken', token);\n\n      if (!token) {\n        logError('Token not found onChain');\n        throw new Error('Token not found onChain');\n      }\n\n      dispatch({\n        type: 'tokenChange',\n        token\n      });\n      dispatch({\n        type: 'civicPass_check_token_status',\n        token\n      });\n      return;\n    } catch (error) {\n      logError('Failed to find Gateway token on-chain, checking with gatekeeper');\n      const state = await gatekeeperClient().getGatekeeperStatus(wallet.publicKey); // if the token is still pending or in review then keep polling on-chain\n\n      if (isTokenPending(state)) {\n        await waitForGatewayToken();\n      } // retries have been exhausted and we still don't have a token\n      // or the gatekeeper threw an error during issuance attempt\n\n\n      if (isTokenCreated(state) || isFailure(state)) {\n        logError('Failed to find Gateway token with gatekeeper status code', types_1.GatekeeperRecordState[state]);\n        dispatch({\n          type: 'tokenNotFoundError'\n        });\n      }\n    }\n  };\n\n  return {\n    waitForGatewayToken\n  };\n};\n\nexports.GatewayTokenActionCreatorImplementation = GatewayTokenActionCreatorImplementation;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","GatewayTokenActionCreatorImplementation","types_1","require","logger_1","utils_1","wallet","chainImplementation","gatekeeperClient","dispatch","networkConfig","logDebug","message","obj","default","debug","logError","error","isTokenCreated","code","isTokenPending","isFailure","pollForActiveOnChainToken","pollUntilConditionMet","findGatewayToken","onChainToken","expiryTime","state","State","ACTIVE","Error","pollChainIntervalMilliseconds","pollChainNumberRetries","waitForGatewayToken","token","type","getGatekeeperStatus","publicKey","GatekeeperRecordState"],"sources":["/Users/nikola/Sites/candy-machine/candy-machine-ui/node_modules/@civic/solana-gateway-react/dist/esm/actionCreator/gatewayToken.actionCreator.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GatewayTokenActionCreatorImplementation = void 0;\n/* eslint-disable @typescript-eslint/no-unused-vars */\nconst types_1 = require(\"../types\");\nconst logger_1 = __importDefault(require(\"../logger\"));\nconst utils_1 = require(\"./utils\");\nconst GatewayTokenActionCreatorImplementation = ({ wallet, chainImplementation, gatekeeperClient, dispatch, networkConfig, }) => {\n    const logDebug = (message, obj = null) => logger_1.default.debug(`[useChain] ${message}`, obj);\n    const logError = (message, obj = null) => logger_1.default.error(`[useChain] ${message}`, obj);\n    const isTokenCreated = (code) => code === 200;\n    const isTokenPending = (code) => code === 202 || code === 404;\n    const isFailure = (code) => !isTokenPending(code) && code >= 400;\n    const pollForActiveOnChainToken = async () => {\n        return (0, utils_1.pollUntilConditionMet)(chainImplementation.findGatewayToken, (onChainToken) => {\n            if (!onChainToken)\n                return false; // keep polling\n            if (!onChainToken.expiryTime)\n                return true;\n            if (onChainToken.state === types_1.State.ACTIVE)\n                return true;\n            throw new Error('Token found but not ACTIVE');\n        }, networkConfig.pollChainIntervalMilliseconds, networkConfig.pollChainNumberRetries);\n    };\n    const waitForGatewayToken = async () => {\n        // poll the gatekeeper until we have a status for a created record\n        // if we don't get a created token, then we consider it a failure\n        try {\n            const token = await pollForActiveOnChainToken();\n            logDebug('Result from pollForActiveOnChainToken', token);\n            if (!token) {\n                logError('Token not found onChain');\n                throw new Error('Token not found onChain');\n            }\n            dispatch({ type: 'tokenChange', token });\n            dispatch({ type: 'civicPass_check_token_status', token });\n            return;\n        }\n        catch (error) {\n            logError('Failed to find Gateway token on-chain, checking with gatekeeper');\n            const state = await gatekeeperClient().getGatekeeperStatus(wallet.publicKey);\n            // if the token is still pending or in review then keep polling on-chain\n            if (isTokenPending(state)) {\n                await waitForGatewayToken();\n            }\n            // retries have been exhausted and we still don't have a token\n            // or the gatekeeper threw an error during issuance attempt\n            if (isTokenCreated(state) || isFailure(state)) {\n                logError('Failed to find Gateway token with gatekeeper status code', types_1.GatekeeperRecordState[state]);\n                dispatch({ type: 'tokenNotFoundError' });\n            }\n        }\n    };\n    return {\n        waitForGatewayToken,\n    };\n};\nexports.GatewayTokenActionCreatorImplementation = GatewayTokenActionCreatorImplementation;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}