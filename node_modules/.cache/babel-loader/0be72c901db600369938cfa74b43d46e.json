{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport BloctoSDK from '@blocto/sdk';\nimport { BaseWalletAdapter, WalletAccountError, WalletAdapterNetwork, WalletConnectionError, WalletDisconnectionError, WalletNotConnectedError, WalletNotFoundError, WalletPublicKeyError, WalletSendTransactionError } from '@solana/wallet-adapter-base';\nimport { PublicKey } from '@solana/web3.js';\nexport class BloctoWalletAdapter extends BaseWalletAdapter {\n  constructor() {\n    let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n    this._connecting = false;\n    this._wallet = null;\n    this._publicKey = null;\n    this._network = config.network || WalletAdapterNetwork.Mainnet;\n  }\n\n  get publicKey() {\n    return this._publicKey;\n  }\n\n  get ready() {\n    return true;\n  }\n\n  get connecting() {\n    return this._connecting;\n  }\n\n  get connected() {\n    return !!this._publicKey;\n  }\n\n  connect() {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (this.connected || this.connecting) return;\n        this._connecting = true;\n        const wallet = new BloctoSDK({\n          solana: {\n            net: this._network\n          }\n        }).solana;\n        if (!wallet) throw new WalletNotFoundError();\n\n        if (!wallet.connected) {\n          try {\n            yield wallet.connect();\n          } catch (error) {\n            throw new WalletConnectionError(error === null || error === void 0 ? void 0 : error.message, error);\n          }\n        }\n\n        const account = wallet.accounts[0];\n        if (!account) throw new WalletAccountError();\n        let publicKey;\n\n        try {\n          publicKey = new PublicKey(account);\n        } catch (error) {\n          throw new WalletPublicKeyError(error === null || error === void 0 ? void 0 : error.message, error);\n        }\n\n        this._wallet = wallet;\n        this._publicKey = publicKey;\n        this.emit('connect');\n      } catch (error) {\n        this.emit('error', error);\n        throw error;\n      } finally {\n        this._connecting = false;\n      }\n    });\n  }\n\n  disconnect() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const wallet = this._wallet;\n\n      if (wallet) {\n        this._wallet = null;\n        this._publicKey = null;\n\n        try {\n          yield wallet.disconnect();\n        } catch (error) {\n          this.emit('error', new WalletDisconnectionError(error === null || error === void 0 ? void 0 : error.message, error));\n        }\n      }\n\n      this.emit('disconnect');\n    });\n  }\n\n  sendTransaction(transaction, connection) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const wallet = this._wallet;\n        if (!wallet) throw new WalletNotConnectedError();\n\n        try {\n          transaction.feePayer || (transaction.feePayer = this.publicKey || undefined);\n          transaction.recentBlockhash || (transaction.recentBlockhash = (yield connection.getRecentBlockhash('finalized')).blockhash);\n          const {\n            signers\n          } = options;\n\n          if (signers === null || signers === void 0 ? void 0 : signers.length) {\n            transaction = yield wallet.convertToProgramWalletTransaction(transaction);\n            transaction.partialSign(...signers);\n          }\n\n          return yield wallet.signAndSendTransaction(transaction, connection);\n        } catch (error) {\n          throw new WalletSendTransactionError(error === null || error === void 0 ? void 0 : error.message, error);\n        }\n      } catch (error) {\n        this.emit('error', error);\n        throw error;\n      }\n    });\n  }\n\n}","map":{"version":3,"sources":["../src/adapter.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,OAAO,SAAP,MAAmD,aAAnD;AACA,SACI,iBADJ,EAGI,kBAHJ,EAII,oBAJJ,EAKI,qBALJ,EAMI,wBANJ,EAQI,uBARJ,EASI,mBATJ,EAUI,oBAVJ,EAWI,0BAXJ,QAYO,6BAZP;AAaA,SAAqB,SAArB,QAAyE,iBAAzE;AAMA,OAAM,MAAO,mBAAP,SAAmC,iBAAnC,CAAoD;EAMtD,WAAA,GAAkD;IAAA,IAAtC,MAAsC,uEAAF,EAAE;IAC9C;IACA,KAAK,WAAL,GAAmB,KAAnB;IACA,KAAK,OAAL,GAAe,IAAf;IACA,KAAK,UAAL,GAAkB,IAAlB;IACA,KAAK,QAAL,GAAgB,MAAM,CAAC,OAAP,IAAkB,oBAAoB,CAAC,OAAvD;EACH;;EAEY,IAAT,SAAS,GAAA;IACT,OAAO,KAAK,UAAZ;EACH;;EAEQ,IAAL,KAAK,GAAA;IACL,OAAO,IAAP;EACH;;EAEa,IAAV,UAAU,GAAA;IACV,OAAO,KAAK,WAAZ;EACH;;EAEY,IAAT,SAAS,GAAA;IACT,OAAO,CAAC,CAAC,KAAK,UAAd;EACH;;EAEK,OAAO,GAAA;;MACT,IAAI;QACA,IAAI,KAAK,SAAL,IAAkB,KAAK,UAA3B,EAAuC;QACvC,KAAK,WAAL,GAAmB,IAAnB;QAEA,MAAM,MAAM,GAAG,IAAI,SAAJ,CAAc;UAAE,MAAM,EAAE;YAAE,GAAG,EAAE,KAAK;UAAZ;QAAV,CAAd,EAAkD,MAAjE;QACA,IAAI,CAAC,MAAL,EAAa,MAAM,IAAI,mBAAJ,EAAN;;QAEb,IAAI,CAAC,MAAM,CAAC,SAAZ,EAAuB;UACnB,IAAI;YACA,MAAM,MAAM,CAAC,OAAP,EAAN;UACH,CAFD,CAEE,OAAO,KAAP,EAAmB;YACjB,MAAM,IAAI,qBAAJ,CAA0B,KAAK,KAAA,IAAL,IAAA,KAAK,KAAA,KAAA,CAAL,GAAK,KAAA,CAAL,GAAA,KAAK,CAAE,OAAjC,EAA0C,KAA1C,CAAN;UACH;QACJ;;QAED,MAAM,OAAO,GAAG,MAAM,CAAC,QAAP,CAAgB,CAAhB,CAAhB;QACA,IAAI,CAAC,OAAL,EAAc,MAAM,IAAI,kBAAJ,EAAN;QAEd,IAAI,SAAJ;;QACA,IAAI;UACA,SAAS,GAAG,IAAI,SAAJ,CAAc,OAAd,CAAZ;QACH,CAFD,CAEE,OAAO,KAAP,EAAmB;UACjB,MAAM,IAAI,oBAAJ,CAAyB,KAAK,KAAA,IAAL,IAAA,KAAK,KAAA,KAAA,CAAL,GAAK,KAAA,CAAL,GAAA,KAAK,CAAE,OAAhC,EAAyC,KAAzC,CAAN;QACH;;QAED,KAAK,OAAL,GAAe,MAAf;QACA,KAAK,UAAL,GAAkB,SAAlB;QAEA,KAAK,IAAL,CAAU,SAAV;MACH,CA7BD,CA6BE,OAAO,KAAP,EAAmB;QACjB,KAAK,IAAL,CAAU,OAAV,EAAmB,KAAnB;QACA,MAAM,KAAN;MACH,CAhCD,SAgCU;QACN,KAAK,WAAL,GAAmB,KAAnB;MACH;IACJ,C;EAAA;;EAEK,UAAU,GAAA;;MACZ,MAAM,MAAM,GAAG,KAAK,OAApB;;MACA,IAAI,MAAJ,EAAY;QACR,KAAK,OAAL,GAAe,IAAf;QACA,KAAK,UAAL,GAAkB,IAAlB;;QAEA,IAAI;UACA,MAAM,MAAM,CAAC,UAAP,EAAN;QACH,CAFD,CAEE,OAAO,KAAP,EAAmB;UACjB,KAAK,IAAL,CAAU,OAAV,EAAmB,IAAI,wBAAJ,CAA6B,KAAK,KAAA,IAAL,IAAA,KAAK,KAAA,KAAA,CAAL,GAAK,KAAA,CAAL,GAAA,KAAK,CAAE,OAApC,EAA6C,KAA7C,CAAnB;QACH;MACJ;;MAED,KAAK,IAAL,CAAU,YAAV;IACH,C;EAAA;;EAEK,eAAe,CACjB,WADiB,EAEjB,UAFiB,EAGmB;IAAA,IAApC,OAAoC,uEAAF,EAAE;;MAEpC,IAAI;QACA,MAAM,MAAM,GAAG,KAAK,OAApB;QACA,IAAI,CAAC,MAAL,EAAa,MAAM,IAAI,uBAAJ,EAAN;;QAEb,IAAI;UACA,WAAW,CAAC,QAAZ,KAAA,WAAW,CAAC,QAAZ,GAAyB,KAAK,SAAL,IAAkB,SAA3C;UACA,WAAW,CAAC,eAAZ,KAAA,WAAW,CAAC,eAAZ,GAAgC,CAAC,MAAM,UAAU,CAAC,kBAAX,CAA8B,WAA9B,CAAP,EAAmD,SAAnF;UAEA,MAAM;YAAE;UAAF,IAAc,OAApB;;UACA,IAAI,OAAO,KAAA,IAAP,IAAA,OAAO,KAAA,KAAA,CAAP,GAAO,KAAA,CAAP,GAAA,OAAO,CAAE,MAAb,EAAqB;YACjB,WAAW,GAAG,MAAM,MAAM,CAAC,iCAAP,CAAyC,WAAzC,CAApB;YACA,WAAW,CAAC,WAAZ,CAAwB,GAAG,OAA3B;UACH;;UAED,OAAO,MAAM,MAAM,CAAC,sBAAP,CAA8B,WAA9B,EAA2C,UAA3C,CAAb;QACH,CAXD,CAWE,OAAO,KAAP,EAAmB;UACjB,MAAM,IAAI,0BAAJ,CAA+B,KAAK,KAAA,IAAL,IAAA,KAAK,KAAA,KAAA,CAAL,GAAK,KAAA,CAAL,GAAA,KAAK,CAAE,OAAtC,EAA+C,KAA/C,CAAN;QACH;MACJ,CAlBD,CAkBE,OAAO,KAAP,EAAmB;QACjB,KAAK,IAAL,CAAU,OAAV,EAAmB,KAAnB;QACA,MAAM,KAAN;MACH;IACJ,C;EAAA;;AA/GqD","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport BloctoSDK from '@blocto/sdk';\nimport { BaseWalletAdapter, WalletAccountError, WalletAdapterNetwork, WalletConnectionError, WalletDisconnectionError, WalletNotConnectedError, WalletNotFoundError, WalletPublicKeyError, WalletSendTransactionError, } from '@solana/wallet-adapter-base';\nimport { PublicKey } from '@solana/web3.js';\nexport class BloctoWalletAdapter extends BaseWalletAdapter {\n    constructor(config = {}) {\n        super();\n        this._connecting = false;\n        this._wallet = null;\n        this._publicKey = null;\n        this._network = config.network || WalletAdapterNetwork.Mainnet;\n    }\n    get publicKey() {\n        return this._publicKey;\n    }\n    get ready() {\n        return true;\n    }\n    get connecting() {\n        return this._connecting;\n    }\n    get connected() {\n        return !!this._publicKey;\n    }\n    connect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                if (this.connected || this.connecting)\n                    return;\n                this._connecting = true;\n                const wallet = new BloctoSDK({ solana: { net: this._network } }).solana;\n                if (!wallet)\n                    throw new WalletNotFoundError();\n                if (!wallet.connected) {\n                    try {\n                        yield wallet.connect();\n                    }\n                    catch (error) {\n                        throw new WalletConnectionError(error === null || error === void 0 ? void 0 : error.message, error);\n                    }\n                }\n                const account = wallet.accounts[0];\n                if (!account)\n                    throw new WalletAccountError();\n                let publicKey;\n                try {\n                    publicKey = new PublicKey(account);\n                }\n                catch (error) {\n                    throw new WalletPublicKeyError(error === null || error === void 0 ? void 0 : error.message, error);\n                }\n                this._wallet = wallet;\n                this._publicKey = publicKey;\n                this.emit('connect');\n            }\n            catch (error) {\n                this.emit('error', error);\n                throw error;\n            }\n            finally {\n                this._connecting = false;\n            }\n        });\n    }\n    disconnect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const wallet = this._wallet;\n            if (wallet) {\n                this._wallet = null;\n                this._publicKey = null;\n                try {\n                    yield wallet.disconnect();\n                }\n                catch (error) {\n                    this.emit('error', new WalletDisconnectionError(error === null || error === void 0 ? void 0 : error.message, error));\n                }\n            }\n            this.emit('disconnect');\n        });\n    }\n    sendTransaction(transaction, connection, options = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const wallet = this._wallet;\n                if (!wallet)\n                    throw new WalletNotConnectedError();\n                try {\n                    transaction.feePayer || (transaction.feePayer = this.publicKey || undefined);\n                    transaction.recentBlockhash || (transaction.recentBlockhash = (yield connection.getRecentBlockhash('finalized')).blockhash);\n                    const { signers } = options;\n                    if (signers === null || signers === void 0 ? void 0 : signers.length) {\n                        transaction = yield wallet.convertToProgramWalletTransaction(transaction);\n                        transaction.partialSign(...signers);\n                    }\n                    return yield wallet.signAndSendTransaction(transaction, connection);\n                }\n                catch (error) {\n                    throw new WalletSendTransactionError(error === null || error === void 0 ? void 0 : error.message, error);\n                }\n            }\n            catch (error) {\n                this.emit('error', error);\n                throw error;\n            }\n        });\n    }\n}\n//# sourceMappingURL=adapter.js.map"]},"metadata":{},"sourceType":"module"}