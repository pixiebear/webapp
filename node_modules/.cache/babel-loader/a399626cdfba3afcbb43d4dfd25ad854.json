{"ast":null,"code":"import assert from \"assert\";\nimport { PublicKey, Transaction, TransactionInstruction } from \"@solana/web3.js\";\nimport { chunks } from \"../utils/common\";\nimport { translateAddress } from \"../program/common\";\nimport { getProvider } from \"../provider\";\n/**\n * Sends a transaction to a program with the given accounts and instruction\n * data.\n */\n\nexport async function invoke(programId, accounts, data, provider) {\n  programId = translateAddress(programId);\n\n  if (!provider) {\n    provider = getProvider();\n  }\n\n  const tx = new Transaction();\n  tx.add(new TransactionInstruction({\n    programId,\n    keys: accounts !== null && accounts !== void 0 ? accounts : [],\n    data\n  }));\n  return await provider.send(tx);\n}\nconst GET_MULTIPLE_ACCOUNTS_LIMIT = 99;\nexport async function getMultipleAccounts(connection, publicKeys) {\n  if (publicKeys.length <= GET_MULTIPLE_ACCOUNTS_LIMIT) {\n    return await getMultipleAccountsCore(connection, publicKeys);\n  } else {\n    const batches = chunks(publicKeys, GET_MULTIPLE_ACCOUNTS_LIMIT);\n    const results = await Promise.all(batches.map(batch => getMultipleAccountsCore(connection, batch)));\n    return results.flat();\n  }\n}\n\nasync function getMultipleAccountsCore(connection, publicKeys) {\n  const args = [publicKeys.map(k => k.toBase58()), {\n    commitment: \"recent\"\n  }]; // @ts-ignore\n\n  const res = await connection._rpcRequest(\"getMultipleAccounts\", args);\n\n  if (res.error) {\n    throw new Error(\"failed to get info about accounts \" + publicKeys.map(k => k.toBase58()).join(\", \") + \": \" + res.error.message);\n  }\n\n  assert(typeof res.result !== \"undefined\");\n  const accounts = [];\n\n  for (const account of res.result.value) {\n    let value = null;\n\n    if (account === null) {\n      accounts.push(null);\n      continue;\n    }\n\n    if (res.result.value) {\n      const {\n        executable,\n        owner,\n        lamports,\n        data\n      } = account;\n      assert(data[1] === \"base64\");\n      value = {\n        executable,\n        owner: new PublicKey(owner),\n        lamports,\n        data: Buffer.from(data[0], \"base64\")\n      };\n    }\n\n    if (value === null) {\n      throw new Error(\"Invalid response\");\n    }\n\n    accounts.push(value);\n  }\n\n  return accounts.map((account, idx) => {\n    if (account === null) {\n      return null;\n    }\n\n    return {\n      publicKey: publicKeys[idx],\n      account\n    };\n  });\n}","map":{"version":3,"sources":["../../../src/utils/rpc.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import assert from \"assert\";\nimport { PublicKey, Transaction, TransactionInstruction, } from \"@solana/web3.js\";\nimport { chunks } from \"../utils/common\";\nimport { translateAddress } from \"../program/common\";\nimport { getProvider } from \"../provider\";\n/**\n * Sends a transaction to a program with the given accounts and instruction\n * data.\n */\nexport async function invoke(programId, accounts, data, provider) {\n    programId = translateAddress(programId);\n    if (!provider) {\n        provider = getProvider();\n    }\n    const tx = new Transaction();\n    tx.add(new TransactionInstruction({\n        programId,\n        keys: accounts !== null && accounts !== void 0 ? accounts : [],\n        data,\n    }));\n    return await provider.send(tx);\n}\nconst GET_MULTIPLE_ACCOUNTS_LIMIT = 99;\nexport async function getMultipleAccounts(connection, publicKeys) {\n    if (publicKeys.length <= GET_MULTIPLE_ACCOUNTS_LIMIT) {\n        return await getMultipleAccountsCore(connection, publicKeys);\n    }\n    else {\n        const batches = chunks(publicKeys, GET_MULTIPLE_ACCOUNTS_LIMIT);\n        const results = await Promise.all(batches.map((batch) => getMultipleAccountsCore(connection, batch)));\n        return results.flat();\n    }\n}\nasync function getMultipleAccountsCore(connection, publicKeys) {\n    const args = [publicKeys.map((k) => k.toBase58()), { commitment: \"recent\" }];\n    // @ts-ignore\n    const res = await connection._rpcRequest(\"getMultipleAccounts\", args);\n    if (res.error) {\n        throw new Error(\"failed to get info about accounts \" +\n            publicKeys.map((k) => k.toBase58()).join(\", \") +\n            \": \" +\n            res.error.message);\n    }\n    assert(typeof res.result !== \"undefined\");\n    const accounts = [];\n    for (const account of res.result.value) {\n        let value = null;\n        if (account === null) {\n            accounts.push(null);\n            continue;\n        }\n        if (res.result.value) {\n            const { executable, owner, lamports, data } = account;\n            assert(data[1] === \"base64\");\n            value = {\n                executable,\n                owner: new PublicKey(owner),\n                lamports,\n                data: Buffer.from(data[0], \"base64\"),\n            };\n        }\n        if (value === null) {\n            throw new Error(\"Invalid response\");\n        }\n        accounts.push(value);\n    }\n    return accounts.map((account, idx) => {\n        if (account === null) {\n            return null;\n        }\n        return {\n            publicKey: publicKeys[idx],\n            account,\n        };\n    });\n}\n//# sourceMappingURL=rpc.js.map"]},"metadata":{},"sourceType":"module"}