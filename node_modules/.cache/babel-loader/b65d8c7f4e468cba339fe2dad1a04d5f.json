{"ast":null,"code":"import camelCase from \"camelcase\";\nimport * as toml from \"toml\";\nimport { PublicKey } from \"@solana/web3.js\";\nimport { Program } from \"./program\";\nimport { isBrowser } from \"./utils/common\";\nlet _populatedWorkspace = false;\n/**\n * The `workspace` namespace provides a convenience API to automatically\n * search for and deserialize [[Program]] objects defined by compiled IDLs\n * in an Anchor workspace.\n *\n * This API is for Node only.\n */\n\nconst workspace = new Proxy({}, {\n  get(workspaceCache, programName) {\n    if (isBrowser) {\n      console.log(\"Workspaces aren't available in the browser\");\n      return undefined;\n    }\n\n    const fs = require(\"fs\");\n\n    const process = require(\"process\");\n\n    if (!_populatedWorkspace) {\n      const path = require(\"path\");\n\n      let projectRoot = process.cwd();\n\n      while (!fs.existsSync(path.join(projectRoot, \"Anchor.toml\"))) {\n        const parentDir = path.dirname(projectRoot);\n\n        if (parentDir === projectRoot) {\n          projectRoot = undefined;\n        }\n\n        projectRoot = parentDir;\n      }\n\n      if (projectRoot === undefined) {\n        throw new Error(\"Could not find workspace root.\");\n      }\n\n      const idlFolder = `${projectRoot}/target/idl`;\n\n      if (!fs.existsSync(idlFolder)) {\n        throw new Error(`${idlFolder} doesn't exist. Did you use \"anchor build\"?`);\n      }\n\n      const idlMap = new Map();\n      fs.readdirSync(idlFolder).forEach(file => {\n        const filePath = `${idlFolder}/${file}`;\n        const idlStr = fs.readFileSync(filePath);\n        const idl = JSON.parse(idlStr);\n        idlMap.set(idl.name, idl);\n        const name = camelCase(idl.name, {\n          pascalCase: true\n        });\n\n        if (idl.metadata && idl.metadata.address) {\n          workspaceCache[name] = new Program(idl, new PublicKey(idl.metadata.address));\n        }\n      }); // Override the workspace programs if the user put them in the config.\n\n      const anchorToml = toml.parse(fs.readFileSync(path.join(projectRoot, \"Anchor.toml\"), \"utf-8\"));\n      const clusterId = anchorToml.provider.cluster;\n\n      if (anchorToml.programs && anchorToml.programs[clusterId]) {\n        attachWorkspaceOverride(workspaceCache, anchorToml.programs[clusterId], idlMap);\n      }\n\n      _populatedWorkspace = true;\n    }\n\n    return workspaceCache[programName];\n  }\n\n});\n\nfunction attachWorkspaceOverride(workspaceCache, overrideConfig, idlMap) {\n  Object.keys(overrideConfig).forEach(programName => {\n    const wsProgramName = camelCase(programName, {\n      pascalCase: true\n    });\n    const entry = overrideConfig[programName];\n    const overrideAddress = new PublicKey(typeof entry === \"string\" ? entry : entry.address);\n    let idl = idlMap.get(programName);\n\n    if (typeof entry !== \"string\" && entry.idl) {\n      idl = JSON.parse(require(\"fs\").readFileSync(entry.idl, \"utf-8\"));\n    }\n\n    if (!idl) {\n      throw new Error(`Error loading workspace IDL for ${programName}`);\n    }\n\n    workspaceCache[wsProgramName] = new Program(idl, overrideAddress);\n  });\n}\n\nexport default workspace;","map":{"version":3,"sources":["../../src/workspace.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import camelCase from \"camelcase\";\nimport * as toml from \"toml\";\nimport { PublicKey } from \"@solana/web3.js\";\nimport { Program } from \"./program\";\nimport { isBrowser } from \"./utils/common\";\nlet _populatedWorkspace = false;\n/**\n * The `workspace` namespace provides a convenience API to automatically\n * search for and deserialize [[Program]] objects defined by compiled IDLs\n * in an Anchor workspace.\n *\n * This API is for Node only.\n */\nconst workspace = new Proxy({}, {\n    get(workspaceCache, programName) {\n        if (isBrowser) {\n            console.log(\"Workspaces aren't available in the browser\");\n            return undefined;\n        }\n        const fs = require(\"fs\");\n        const process = require(\"process\");\n        if (!_populatedWorkspace) {\n            const path = require(\"path\");\n            let projectRoot = process.cwd();\n            while (!fs.existsSync(path.join(projectRoot, \"Anchor.toml\"))) {\n                const parentDir = path.dirname(projectRoot);\n                if (parentDir === projectRoot) {\n                    projectRoot = undefined;\n                }\n                projectRoot = parentDir;\n            }\n            if (projectRoot === undefined) {\n                throw new Error(\"Could not find workspace root.\");\n            }\n            const idlFolder = `${projectRoot}/target/idl`;\n            if (!fs.existsSync(idlFolder)) {\n                throw new Error(`${idlFolder} doesn't exist. Did you use \"anchor build\"?`);\n            }\n            const idlMap = new Map();\n            fs.readdirSync(idlFolder).forEach((file) => {\n                const filePath = `${idlFolder}/${file}`;\n                const idlStr = fs.readFileSync(filePath);\n                const idl = JSON.parse(idlStr);\n                idlMap.set(idl.name, idl);\n                const name = camelCase(idl.name, { pascalCase: true });\n                if (idl.metadata && idl.metadata.address) {\n                    workspaceCache[name] = new Program(idl, new PublicKey(idl.metadata.address));\n                }\n            });\n            // Override the workspace programs if the user put them in the config.\n            const anchorToml = toml.parse(fs.readFileSync(path.join(projectRoot, \"Anchor.toml\"), \"utf-8\"));\n            const clusterId = anchorToml.provider.cluster;\n            if (anchorToml.programs && anchorToml.programs[clusterId]) {\n                attachWorkspaceOverride(workspaceCache, anchorToml.programs[clusterId], idlMap);\n            }\n            _populatedWorkspace = true;\n        }\n        return workspaceCache[programName];\n    },\n});\nfunction attachWorkspaceOverride(workspaceCache, overrideConfig, idlMap) {\n    Object.keys(overrideConfig).forEach((programName) => {\n        const wsProgramName = camelCase(programName, { pascalCase: true });\n        const entry = overrideConfig[programName];\n        const overrideAddress = new PublicKey(typeof entry === \"string\" ? entry : entry.address);\n        let idl = idlMap.get(programName);\n        if (typeof entry !== \"string\" && entry.idl) {\n            idl = JSON.parse(require(\"fs\").readFileSync(entry.idl, \"utf-8\"));\n        }\n        if (!idl) {\n            throw new Error(`Error loading workspace IDL for ${programName}`);\n        }\n        workspaceCache[wsProgramName] = new Program(idl, overrideAddress);\n    });\n}\nexport default workspace;\n//# sourceMappingURL=workspace.js.map"]},"metadata":{},"sourceType":"module"}