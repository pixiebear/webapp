{"ast":null,"code":"import _slicedToArray from \"/Users/nikola/Sites/candy-machine/candy-machine-ui/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _asyncToGenerator from \"/Users/nikola/Sites/candy-machine/candy-machine-ui/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _regeneratorRuntime from \"/Users/nikola/Sites/candy-machine/candy-machine-ui/node_modules/@babel/runtime/regenerator/index.js\";\nimport BN from \"bn.js\";\nimport { sha256 as sha256Sync } from \"js-sha256\";\nimport { PublicKey } from \"@solana/web3.js\";\nimport { translateAddress } from \"../program/common\"; // Sync version of web3.PublicKey.createWithSeed.\n\nexport function createWithSeedSync(fromPublicKey, seed, programId) {\n  var buffer = Buffer.concat([fromPublicKey.toBuffer(), Buffer.from(seed), programId.toBuffer()]);\n  var hash = sha256Sync.digest(buffer);\n  return new PublicKey(Buffer.from(hash));\n} // Sync version of web3.PublicKey.createProgramAddress.\n\nexport function createProgramAddressSync(seeds, programId) {\n  var MAX_SEED_LENGTH = 32;\n  var buffer = Buffer.alloc(0);\n  seeds.forEach(function (seed) {\n    if (seed.length > MAX_SEED_LENGTH) {\n      throw new TypeError(\"Max seed length exceeded\");\n    }\n\n    buffer = Buffer.concat([buffer, toBuffer(seed)]);\n  });\n  buffer = Buffer.concat([buffer, programId.toBuffer(), Buffer.from(\"ProgramDerivedAddress\")]);\n  var hash = sha256Sync(new Uint8Array(buffer));\n  var publicKeyBytes = new BN(hash, 16).toArray(undefined, 32);\n\n  if (PublicKey.isOnCurve(new Uint8Array(publicKeyBytes))) {\n    throw new Error(\"Invalid seeds, address must fall off the curve\");\n  }\n\n  return new PublicKey(publicKeyBytes);\n} // Sync version of web3.PublicKey.findProgramAddress.\n\nexport function findProgramAddressSync(seeds, programId) {\n  var nonce = 255;\n  var address;\n\n  while (nonce != 0) {\n    try {\n      var seedsWithNonce = seeds.concat(Buffer.from([nonce]));\n      address = createProgramAddressSync(seedsWithNonce, programId);\n    } catch (err) {\n      if (err instanceof TypeError) {\n        throw err;\n      }\n\n      nonce--;\n      continue;\n    }\n\n    return [address, nonce];\n  }\n\n  throw new Error(\"Unable to find a viable program address nonce\");\n}\n\nvar toBuffer = function toBuffer(arr) {\n  if (arr instanceof Buffer) {\n    return arr;\n  } else if (arr instanceof Uint8Array) {\n    return Buffer.from(arr.buffer, arr.byteOffset, arr.byteLength);\n  } else {\n    return Buffer.from(arr);\n  }\n};\n\nexport function associated(_x) {\n  return _associated.apply(this, arguments);\n}\n\nfunction _associated() {\n  _associated = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(programId) {\n    var seeds,\n        _len,\n        args,\n        _key,\n        _yield$PublicKey$find,\n        _yield$PublicKey$find2,\n        assoc,\n        _args = arguments;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            seeds = [Buffer.from([97, 110, 99, 104, 111, 114])]; // b\"anchor\".\n\n            for (_len = _args.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n              args[_key - 1] = _args[_key];\n            }\n\n            args.forEach(function (arg) {\n              seeds.push( // @ts-ignore\n              arg.buffer !== undefined ? arg : translateAddress(arg).toBuffer());\n            });\n            _context.next = 5;\n            return PublicKey.findProgramAddress(seeds, translateAddress(programId));\n\n          case 5:\n            _yield$PublicKey$find = _context.sent;\n            _yield$PublicKey$find2 = _slicedToArray(_yield$PublicKey$find, 1);\n            assoc = _yield$PublicKey$find2[0];\n            return _context.abrupt(\"return\", assoc);\n\n          case 9:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _associated.apply(this, arguments);\n}","map":{"version":3,"sources":["../../../src/utils/pubkey.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import BN from \"bn.js\";\nimport { sha256 as sha256Sync } from \"js-sha256\";\nimport { PublicKey } from \"@solana/web3.js\";\nimport { translateAddress } from \"../program/common\";\n// Sync version of web3.PublicKey.createWithSeed.\nexport function createWithSeedSync(fromPublicKey, seed, programId) {\n    const buffer = Buffer.concat([\n        fromPublicKey.toBuffer(),\n        Buffer.from(seed),\n        programId.toBuffer(),\n    ]);\n    const hash = sha256Sync.digest(buffer);\n    return new PublicKey(Buffer.from(hash));\n}\n// Sync version of web3.PublicKey.createProgramAddress.\nexport function createProgramAddressSync(seeds, programId) {\n    const MAX_SEED_LENGTH = 32;\n    let buffer = Buffer.alloc(0);\n    seeds.forEach(function (seed) {\n        if (seed.length > MAX_SEED_LENGTH) {\n            throw new TypeError(`Max seed length exceeded`);\n        }\n        buffer = Buffer.concat([buffer, toBuffer(seed)]);\n    });\n    buffer = Buffer.concat([\n        buffer,\n        programId.toBuffer(),\n        Buffer.from(\"ProgramDerivedAddress\"),\n    ]);\n    let hash = sha256Sync(new Uint8Array(buffer));\n    let publicKeyBytes = new BN(hash, 16).toArray(undefined, 32);\n    if (PublicKey.isOnCurve(new Uint8Array(publicKeyBytes))) {\n        throw new Error(`Invalid seeds, address must fall off the curve`);\n    }\n    return new PublicKey(publicKeyBytes);\n}\n// Sync version of web3.PublicKey.findProgramAddress.\nexport function findProgramAddressSync(seeds, programId) {\n    let nonce = 255;\n    let address;\n    while (nonce != 0) {\n        try {\n            const seedsWithNonce = seeds.concat(Buffer.from([nonce]));\n            address = createProgramAddressSync(seedsWithNonce, programId);\n        }\n        catch (err) {\n            if (err instanceof TypeError) {\n                throw err;\n            }\n            nonce--;\n            continue;\n        }\n        return [address, nonce];\n    }\n    throw new Error(`Unable to find a viable program address nonce`);\n}\nconst toBuffer = (arr) => {\n    if (arr instanceof Buffer) {\n        return arr;\n    }\n    else if (arr instanceof Uint8Array) {\n        return Buffer.from(arr.buffer, arr.byteOffset, arr.byteLength);\n    }\n    else {\n        return Buffer.from(arr);\n    }\n};\nexport async function associated(programId, ...args) {\n    let seeds = [Buffer.from([97, 110, 99, 104, 111, 114])]; // b\"anchor\".\n    args.forEach((arg) => {\n        seeds.push(\n        // @ts-ignore\n        arg.buffer !== undefined ? arg : translateAddress(arg).toBuffer());\n    });\n    const [assoc] = await PublicKey.findProgramAddress(seeds, translateAddress(programId));\n    return assoc;\n}\n//# sourceMappingURL=pubkey.js.map"]},"metadata":{},"sourceType":"module"}