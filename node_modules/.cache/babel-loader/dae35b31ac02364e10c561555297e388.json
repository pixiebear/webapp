{"ast":null,"code":"var _jsxFileName = \"/Users/nikola/Sites/candy-machine/candy-machine-ui/src/components/faq/Card/Title.tsx\",\n    _s = $RefreshSig$();\n\nimport * as React from \"react\";\nimport { motion, useInvertedScale } from \"framer-motion\";\nimport { closeSpring, openSpring } from \"./animations\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const Title = _ref => {\n  _s();\n\n  let {\n    title,\n    category,\n    isSelected\n  } = _ref;\n  const inverted = useInvertedScale();\n  const x = isSelected ? 30 : 15;\n  const y = x;\n  return /*#__PURE__*/_jsxDEV(motion.div, {\n    className: \"title-container\",\n    initial: false,\n    animate: {\n      x,\n      y\n    },\n    transition: isSelected ? openSpring : closeSpring,\n    transformTemplate: scaleTranslate,\n    style: { ...inverted,\n      originX: 0,\n      originY: 0\n    },\n    children: [/*#__PURE__*/_jsxDEV(\"span\", {\n      className: \"category\",\n      children: category\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 19,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"h2\", {\n      children: title\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 20,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 11,\n    columnNumber: 5\n  }, this);\n};\n/**\n * `transform` is order-dependent, so if you scale(0.5) before translateX(100px),\n * the visual translate will only be 50px.\n *\n * The intuitive pattern is to translate before doing things like scale and\n * rotate that will affect the coordinate space. So Framer Motion takes an\n * opinion on that and allows you to animate them\n * individually without having to write a whole transform string.\n *\n * However in this component we're doing something novel by inverting\n * the scale of the parent component. Because of this we want to translate\n * through scaled coordinate space, and can use the transformTemplate prop to do so.\n */\n\n_s(Title, \"acVW8dtbpArHIxjm5CyMHfUagfk=\", false, function () {\n  return [useInvertedScale];\n});\n\n_c = Title;\n\nconst scaleTranslate = _ref2 => {\n  let {\n    x,\n    y,\n    scaleX,\n    scaleY\n  } = _ref2;\n  return `scaleX(${scaleX}) scaleY(${scaleY}) translate(${x}, ${y}) translateZ(0)`;\n};\n\nvar _c;\n\n$RefreshReg$(_c, \"Title\");","map":{"version":3,"names":["React","motion","useInvertedScale","closeSpring","openSpring","Title","title","category","isSelected","inverted","x","y","scaleTranslate","originX","originY","scaleX","scaleY"],"sources":["/Users/nikola/Sites/candy-machine/candy-machine-ui/src/components/faq/Card/Title.tsx"],"sourcesContent":["import * as React from \"react\";\nimport { motion, useInvertedScale } from \"framer-motion\";\nimport { closeSpring, openSpring } from \"./animations\";\n\nexport const Title = ({ title, category, isSelected }) => {\n  const inverted = useInvertedScale();\n  const x = isSelected ? 30 : 15;\n  const y = x;\n\n  return (\n    <motion.div\n      className=\"title-container\"\n      initial={false}\n      animate={{ x, y }}\n      transition={isSelected ? openSpring : closeSpring}\n      transformTemplate={scaleTranslate}\n      style={{ ...inverted, originX: 0, originY: 0 }}\n    >\n      <span className=\"category\">{category}</span>\n      <h2>{title}</h2>\n    </motion.div>\n  );\n};\n\n/**\n * `transform` is order-dependent, so if you scale(0.5) before translateX(100px),\n * the visual translate will only be 50px.\n *\n * The intuitive pattern is to translate before doing things like scale and\n * rotate that will affect the coordinate space. So Framer Motion takes an\n * opinion on that and allows you to animate them\n * individually without having to write a whole transform string.\n *\n * However in this component we're doing something novel by inverting\n * the scale of the parent component. Because of this we want to translate\n * through scaled coordinate space, and can use the transformTemplate prop to do so.\n */\nconst scaleTranslate = ({ x, y, scaleX, scaleY }) =>\n  `scaleX(${scaleX}) scaleY(${scaleY}) translate(${x}, ${y}) translateZ(0)`;\n"],"mappings":";;;AAAA,OAAO,KAAKA,KAAZ,MAAuB,OAAvB;AACA,SAASC,MAAT,EAAiBC,gBAAjB,QAAyC,eAAzC;AACA,SAASC,WAAT,EAAsBC,UAAtB,QAAwC,cAAxC;;AAEA,OAAO,MAAMC,KAAK,GAAG,QAAqC;EAAA;;EAAA,IAApC;IAAEC,KAAF;IAASC,QAAT;IAAmBC;EAAnB,CAAoC;EACxD,MAAMC,QAAQ,GAAGP,gBAAgB,EAAjC;EACA,MAAMQ,CAAC,GAAGF,UAAU,GAAG,EAAH,GAAQ,EAA5B;EACA,MAAMG,CAAC,GAAGD,CAAV;EAEA,oBACE,QAAC,MAAD,CAAQ,GAAR;IACE,SAAS,EAAC,iBADZ;IAEE,OAAO,EAAE,KAFX;IAGE,OAAO,EAAE;MAAEA,CAAF;MAAKC;IAAL,CAHX;IAIE,UAAU,EAAEH,UAAU,GAAGJ,UAAH,GAAgBD,WAJxC;IAKE,iBAAiB,EAAES,cALrB;IAME,KAAK,EAAE,EAAE,GAAGH,QAAL;MAAeI,OAAO,EAAE,CAAxB;MAA2BC,OAAO,EAAE;IAApC,CANT;IAAA,wBAQE;MAAM,SAAS,EAAC,UAAhB;MAAA,UAA4BP;IAA5B;MAAA;MAAA;MAAA;IAAA,QARF,eASE;MAAA,UAAKD;IAAL;MAAA;MAAA;MAAA;IAAA,QATF;EAAA;IAAA;IAAA;IAAA;EAAA,QADF;AAaD,CAlBM;AAoBP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;GAhCaD,K;UACMH,gB;;;KADNG,K;;AAiCb,MAAMO,cAAc,GAAG;EAAA,IAAC;IAAEF,CAAF;IAAKC,CAAL;IAAQI,MAAR;IAAgBC;EAAhB,CAAD;EAAA,OACpB,UAASD,MAAO,YAAWC,MAAO,eAAcN,CAAE,KAAIC,CAAE,iBADpC;AAAA,CAAvB"},"metadata":{},"sourceType":"module"}