{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport Wallet from '@project-serum/sol-wallet-adapter';\nimport { BaseMessageSignerWalletAdapter, pollUntilReady, WalletAdapterNetwork, WalletConnectionError, WalletDisconnectedError, WalletDisconnectionError, WalletError, WalletNotConnectedError, WalletNotFoundError, WalletSignMessageError, WalletSignTransactionError, WalletTimeoutError, WalletWindowBlockedError, WalletWindowClosedError } from '@solana/wallet-adapter-base';\nexport class SolletWalletAdapter extends BaseMessageSignerWalletAdapter {\n  constructor() {\n    let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n\n    this._disconnected = () => {\n      const wallet = this._wallet;\n\n      if (wallet) {\n        wallet.off('disconnect', this._disconnected);\n        this._wallet = null;\n        this.emit('error', new WalletDisconnectedError());\n        this.emit('disconnect');\n      }\n    };\n\n    this._provider = config.provider || (typeof window === 'undefined' ? undefined : window.sollet);\n    this._network = config.network || WalletAdapterNetwork.Mainnet;\n    this._connecting = false;\n    this._wallet = null;\n    if (!this.ready) pollUntilReady(this, config.pollInterval || 1000, config.pollCount || 3);\n  }\n\n  get publicKey() {\n    var _a;\n\n    return ((_a = this._wallet) === null || _a === void 0 ? void 0 : _a.publicKey) || null;\n  }\n\n  get ready() {\n    var _a;\n\n    return typeof this._provider === 'string' || typeof window !== 'undefined' && typeof ((_a = window.sollet) === null || _a === void 0 ? void 0 : _a.postMessage) === 'function';\n  }\n\n  get connecting() {\n    return this._connecting;\n  }\n\n  get connected() {\n    var _a;\n\n    return !!((_a = this._wallet) === null || _a === void 0 ? void 0 : _a.connected);\n  }\n\n  connect() {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (this.connected || this.connecting) return;\n        this._connecting = true;\n        const provider = this._provider || typeof window !== 'undefined' && window.sollet;\n        if (!provider) throw new WalletNotFoundError();\n        let wallet;\n\n        try {\n          wallet = new Wallet(provider, this._network); // HACK: sol-wallet-adapter doesn't reject or emit an event if the popup or extension is closed or blocked\n\n          const handleDisconnect = wallet.handleDisconnect;\n          let timeout;\n          let interval;\n\n          try {\n            yield new Promise((resolve, reject) => {\n              const connect = () => {\n                if (timeout) clearTimeout(timeout);\n                wallet.off('connect', connect);\n                resolve();\n              };\n\n              wallet.handleDisconnect = function () {\n                wallet.off('connect', connect);\n                reject(new WalletWindowClosedError());\n\n                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n                  args[_key] = arguments[_key];\n                }\n\n                return handleDisconnect.apply(wallet, args);\n              };\n\n              wallet.on('connect', connect);\n              wallet.connect().catch(reason => {\n                wallet.off('connect', connect);\n                reject(reason);\n              });\n\n              if (typeof provider === 'string') {\n                let count = 0;\n                interval = setInterval(() => {\n                  const popup = wallet._popup;\n\n                  if (popup) {\n                    if (popup.closed) reject(new WalletWindowClosedError());\n                  } else {\n                    if (count > 50) reject(new WalletWindowBlockedError());\n                  }\n\n                  count++;\n                }, 100);\n              } else {\n                // HACK: sol-wallet-adapter doesn't reject or emit an event if the extension is closed or ignored\n                timeout = setTimeout(() => reject(new WalletTimeoutError()), 10000);\n              }\n            });\n          } finally {\n            wallet.handleDisconnect = handleDisconnect;\n            if (interval) clearInterval(interval);\n          }\n        } catch (error) {\n          if (error instanceof WalletError) throw error;\n          throw new WalletConnectionError(error === null || error === void 0 ? void 0 : error.message, error);\n        }\n\n        wallet.on('disconnect', this._disconnected);\n        this._wallet = wallet;\n        this.emit('connect');\n      } catch (error) {\n        this.emit('error', error);\n        throw error;\n      } finally {\n        this._connecting = false;\n      }\n    });\n  }\n\n  disconnect() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const wallet = this._wallet;\n\n      if (wallet) {\n        wallet.off('disconnect', this._disconnected);\n        this._wallet = null; // HACK: sol-wallet-adapter doesn't reliably fulfill its promise or emit an event on disconnect\n\n        const handleDisconnect = wallet.handleDisconnect;\n\n        try {\n          yield new Promise((resolve, reject) => {\n            const timeout = setTimeout(() => resolve(), 250);\n\n            wallet.handleDisconnect = function () {\n              clearTimeout(timeout);\n              resolve(); // HACK: sol-wallet-adapter rejects with an uncaught promise error\n\n              wallet._responsePromises = new Map();\n\n              for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n                args[_key2] = arguments[_key2];\n              }\n\n              return handleDisconnect.apply(wallet, args);\n            };\n\n            wallet.disconnect().then(() => {\n              clearTimeout(timeout);\n              resolve();\n            }, error => {\n              clearTimeout(timeout); // HACK: sol-wallet-adapter rejects with an error on disconnect\n\n              if ((error === null || error === void 0 ? void 0 : error.message) === 'Wallet disconnected') {\n                resolve();\n              } else {\n                reject(error);\n              }\n            });\n          });\n        } catch (error) {\n          this.emit('error', new WalletDisconnectionError(error === null || error === void 0 ? void 0 : error.message, error));\n        } finally {\n          wallet.handleDisconnect = handleDisconnect;\n        }\n      }\n\n      this.emit('disconnect');\n    });\n  }\n\n  signTransaction(transaction) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const wallet = this._wallet;\n        if (!wallet) throw new WalletNotConnectedError();\n\n        try {\n          return (yield wallet.signTransaction(transaction)) || transaction;\n        } catch (error) {\n          throw new WalletSignTransactionError(error === null || error === void 0 ? void 0 : error.message, error);\n        }\n      } catch (error) {\n        this.emit('error', error);\n        throw error;\n      }\n    });\n  }\n\n  signAllTransactions(transactions) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const wallet = this._wallet;\n        if (!wallet) throw new WalletNotConnectedError();\n\n        try {\n          return (yield wallet.signAllTransactions(transactions)) || transactions;\n        } catch (error) {\n          throw new WalletSignTransactionError(error === null || error === void 0 ? void 0 : error.message, error);\n        }\n      } catch (error) {\n        this.emit('error', error);\n        throw error;\n      }\n    });\n  }\n\n  signMessage(message) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const wallet = this._wallet;\n        if (!wallet) throw new WalletNotConnectedError();\n\n        try {\n          const {\n            signature\n          } = yield wallet.sign(message, 'utf8');\n          return Uint8Array.from(signature);\n        } catch (error) {\n          throw new WalletSignMessageError(error === null || error === void 0 ? void 0 : error.message, error);\n        }\n      } catch (error) {\n        this.emit('error', error);\n        throw error;\n      }\n    });\n  }\n\n}","map":{"version":3,"sources":["../src/adapter.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport Wallet from '@project-serum/sol-wallet-adapter';\nimport { BaseMessageSignerWalletAdapter, pollUntilReady, WalletAdapterNetwork, WalletConnectionError, WalletDisconnectedError, WalletDisconnectionError, WalletError, WalletNotConnectedError, WalletNotFoundError, WalletSignMessageError, WalletSignTransactionError, WalletTimeoutError, WalletWindowBlockedError, WalletWindowClosedError, } from '@solana/wallet-adapter-base';\nexport class SolletWalletAdapter extends BaseMessageSignerWalletAdapter {\n    constructor(config = {}) {\n        super();\n        this._disconnected = () => {\n            const wallet = this._wallet;\n            if (wallet) {\n                wallet.off('disconnect', this._disconnected);\n                this._wallet = null;\n                this.emit('error', new WalletDisconnectedError());\n                this.emit('disconnect');\n            }\n        };\n        this._provider = config.provider || (typeof window === 'undefined' ? undefined : window.sollet);\n        this._network = config.network || WalletAdapterNetwork.Mainnet;\n        this._connecting = false;\n        this._wallet = null;\n        if (!this.ready)\n            pollUntilReady(this, config.pollInterval || 1000, config.pollCount || 3);\n    }\n    get publicKey() {\n        var _a;\n        return ((_a = this._wallet) === null || _a === void 0 ? void 0 : _a.publicKey) || null;\n    }\n    get ready() {\n        var _a;\n        return (typeof this._provider === 'string' ||\n            (typeof window !== 'undefined' && typeof ((_a = window.sollet) === null || _a === void 0 ? void 0 : _a.postMessage) === 'function'));\n    }\n    get connecting() {\n        return this._connecting;\n    }\n    get connected() {\n        var _a;\n        return !!((_a = this._wallet) === null || _a === void 0 ? void 0 : _a.connected);\n    }\n    connect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                if (this.connected || this.connecting)\n                    return;\n                this._connecting = true;\n                const provider = this._provider || (typeof window !== 'undefined' && window.sollet);\n                if (!provider)\n                    throw new WalletNotFoundError();\n                let wallet;\n                try {\n                    wallet = new Wallet(provider, this._network);\n                    // HACK: sol-wallet-adapter doesn't reject or emit an event if the popup or extension is closed or blocked\n                    const handleDisconnect = wallet.handleDisconnect;\n                    let timeout;\n                    let interval;\n                    try {\n                        yield new Promise((resolve, reject) => {\n                            const connect = () => {\n                                if (timeout)\n                                    clearTimeout(timeout);\n                                wallet.off('connect', connect);\n                                resolve();\n                            };\n                            wallet.handleDisconnect = (...args) => {\n                                wallet.off('connect', connect);\n                                reject(new WalletWindowClosedError());\n                                return handleDisconnect.apply(wallet, args);\n                            };\n                            wallet.on('connect', connect);\n                            wallet.connect().catch((reason) => {\n                                wallet.off('connect', connect);\n                                reject(reason);\n                            });\n                            if (typeof provider === 'string') {\n                                let count = 0;\n                                interval = setInterval(() => {\n                                    const popup = wallet._popup;\n                                    if (popup) {\n                                        if (popup.closed)\n                                            reject(new WalletWindowClosedError());\n                                    }\n                                    else {\n                                        if (count > 50)\n                                            reject(new WalletWindowBlockedError());\n                                    }\n                                    count++;\n                                }, 100);\n                            }\n                            else {\n                                // HACK: sol-wallet-adapter doesn't reject or emit an event if the extension is closed or ignored\n                                timeout = setTimeout(() => reject(new WalletTimeoutError()), 10000);\n                            }\n                        });\n                    }\n                    finally {\n                        wallet.handleDisconnect = handleDisconnect;\n                        if (interval)\n                            clearInterval(interval);\n                    }\n                }\n                catch (error) {\n                    if (error instanceof WalletError)\n                        throw error;\n                    throw new WalletConnectionError(error === null || error === void 0 ? void 0 : error.message, error);\n                }\n                wallet.on('disconnect', this._disconnected);\n                this._wallet = wallet;\n                this.emit('connect');\n            }\n            catch (error) {\n                this.emit('error', error);\n                throw error;\n            }\n            finally {\n                this._connecting = false;\n            }\n        });\n    }\n    disconnect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const wallet = this._wallet;\n            if (wallet) {\n                wallet.off('disconnect', this._disconnected);\n                this._wallet = null;\n                // HACK: sol-wallet-adapter doesn't reliably fulfill its promise or emit an event on disconnect\n                const handleDisconnect = wallet.handleDisconnect;\n                try {\n                    yield new Promise((resolve, reject) => {\n                        const timeout = setTimeout(() => resolve(), 250);\n                        wallet.handleDisconnect = (...args) => {\n                            clearTimeout(timeout);\n                            resolve();\n                            // HACK: sol-wallet-adapter rejects with an uncaught promise error\n                            wallet._responsePromises = new Map();\n                            return handleDisconnect.apply(wallet, args);\n                        };\n                        wallet.disconnect().then(() => {\n                            clearTimeout(timeout);\n                            resolve();\n                        }, (error) => {\n                            clearTimeout(timeout);\n                            // HACK: sol-wallet-adapter rejects with an error on disconnect\n                            if ((error === null || error === void 0 ? void 0 : error.message) === 'Wallet disconnected') {\n                                resolve();\n                            }\n                            else {\n                                reject(error);\n                            }\n                        });\n                    });\n                }\n                catch (error) {\n                    this.emit('error', new WalletDisconnectionError(error === null || error === void 0 ? void 0 : error.message, error));\n                }\n                finally {\n                    wallet.handleDisconnect = handleDisconnect;\n                }\n            }\n            this.emit('disconnect');\n        });\n    }\n    signTransaction(transaction) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const wallet = this._wallet;\n                if (!wallet)\n                    throw new WalletNotConnectedError();\n                try {\n                    return (yield wallet.signTransaction(transaction)) || transaction;\n                }\n                catch (error) {\n                    throw new WalletSignTransactionError(error === null || error === void 0 ? void 0 : error.message, error);\n                }\n            }\n            catch (error) {\n                this.emit('error', error);\n                throw error;\n            }\n        });\n    }\n    signAllTransactions(transactions) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const wallet = this._wallet;\n                if (!wallet)\n                    throw new WalletNotConnectedError();\n                try {\n                    return (yield wallet.signAllTransactions(transactions)) || transactions;\n                }\n                catch (error) {\n                    throw new WalletSignTransactionError(error === null || error === void 0 ? void 0 : error.message, error);\n                }\n            }\n            catch (error) {\n                this.emit('error', error);\n                throw error;\n            }\n        });\n    }\n    signMessage(message) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const wallet = this._wallet;\n                if (!wallet)\n                    throw new WalletNotConnectedError();\n                try {\n                    const { signature } = yield wallet.sign(message, 'utf8');\n                    return Uint8Array.from(signature);\n                }\n                catch (error) {\n                    throw new WalletSignMessageError(error === null || error === void 0 ? void 0 : error.message, error);\n                }\n            }\n            catch (error) {\n                this.emit('error', error);\n                throw error;\n            }\n        });\n    }\n}\n//# sourceMappingURL=adapter.js.map"]},"metadata":{},"sourceType":"module"}