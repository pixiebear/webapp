{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/nikola/Sites/candy-machine/candy-machine-ui/node_modules/@babel/runtime/regenerator/index.js\");\n\nvar _asyncToGenerator = require(\"/Users/nikola/Sites/candy-machine/candy-machine-ui/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.reducer = void 0;\n\nvar react_1 = require(\"react\");\n\nvar utils_1 = require(\"../useReducer/utils\");\n\nvar logger_1 = __importDefault(require(\"../logger\"));\n\nvar types_1 = require(\"../types\");\n\nvar tokenUtils_1 = require(\"../utils/tokenUtils\");\n\nvar reducer = function reducer(state, action) {\n  switch (action.type) {\n    case 'refresh_start':\n      {\n        return Object.assign(Object.assign({}, state), {\n          walletPowoInProgress: false,\n          powoFinished: false,\n          powoRequested: undefined,\n          refreshInProgress: true,\n          gatewayStatus: types_1.GatewayStatus.REFRESH_TOKEN_REQUIRED\n        });\n      }\n\n    case 'refresh_status_check':\n      {\n        return Object.assign(Object.assign({}, state), {\n          refreshTokenState: types_1.RefreshTokenState.IN_PROGRESS\n        });\n      }\n\n    case 'refresh_complete':\n      {\n        return Object.assign(Object.assign({}, state), {\n          refreshTokenState: types_1.RefreshTokenState.COMPLETED,\n          gatewayStatus: (0, utils_1.statusFromToken)(state, state.gatewayToken),\n          refreshTimeoutId: undefined,\n          civicPass: Object.assign(Object.assign({}, state.civicPass), {\n            responsePayload: undefined\n          })\n        });\n      }\n\n    case 'refresh_failed':\n      {\n        return Object.assign(Object.assign({}, state), {\n          refreshTokenState: types_1.RefreshTokenState.FAILED,\n          gatewayStatus: (0, utils_1.statusFromToken)(state, state.gatewayToken),\n          civicPass: Object.assign(Object.assign({}, state.civicPass), {\n            responsePayload: undefined\n          })\n        });\n      }\n\n    case 'refresh_with_powo_in_progress':\n      {\n        return Object.assign(Object.assign({}, state), {\n          renderIframe: false,\n          iframeMinimized: true,\n          gatewayStatus: types_1.GatewayStatus.CHECKING\n        });\n      }\n\n    case 'refresh_clear_timeout':\n      return Object.assign(Object.assign({}, state), {\n        refreshTimeoutId: undefined\n      });\n\n    case 'refresh_set_timeout':\n      return Object.assign(Object.assign({}, state), {\n        refreshTimeoutId: action.refreshTimeoutId\n      });\n\n    case 'refresh_token_success':\n      return Object.assign(Object.assign({}, state), {\n        refreshTokenState: types_1.RefreshTokenState.WAIT_FOR_ON_CHAIN\n      });\n\n    default:\n      return state;\n  }\n};\n\nexports.reducer = reducer;\n\nvar useRefresh = function useRefresh(_ref, state, dispatch) {\n  var stage = _ref.stage,\n      gatekeeperClient = _ref.gatekeeperClient,\n      networkConfig = _ref.networkConfig;\n  var refreshTimeoutId = state.refreshTimeoutId,\n      gatewayToken = state.gatewayToken,\n      gatekeeperNetworkAddress = state.gatekeeperNetworkAddress,\n      ownerSigns = state.ownerSigns,\n      walletAddress = state.walletAddress;\n\n  var logDebug = function logDebug(message) {\n    var obj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return logger_1.default.debug(\"[useRefresh] \".concat(message), obj);\n  };\n\n  var setTimeoutForRefresh = (0, react_1.useRef)(null);\n  /**\n   * Start a timeout based on the expiration of the GatewayToken that will check if a token needs to be refreshed\n   * event, triggering the refreshFlow\n   */\n\n  var checkForRefreshWithTimeout = (0, react_1.useCallback)(function () {\n    logDebug('Checking if refresh required', refreshTimeoutId);\n    dispatch({\n      type: 'refresh_status_check'\n    });\n\n    if (!refreshTimeoutId && (gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.expiryTime)) {\n      var tokenExpirationMarginSeconds = networkConfig.tokenExpirationMarginSeconds;\n      var checkForExpirationIntervalMilliseconds = (0, tokenUtils_1.getTokenRefreshIntervalMilliseconds)(gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.expiryTime, tokenExpirationMarginSeconds);\n      var timeoutId = setTimeout(function () {\n        var shouldRefresh = (0, tokenUtils_1.isTokenRefreshRequired)({\n          gatewayToken: gatewayToken,\n          tokenExpirationMarginSeconds: tokenExpirationMarginSeconds\n        });\n\n        if (shouldRefresh) {\n          logDebug('Refreshing Gateway Token');\n          dispatch({\n            type: 'refresh_start'\n          });\n          dispatch({\n            type: 'civicPass_check_token_status'\n          });\n          return;\n        }\n\n        logDebug('Skipping refresh', {\n          gatewayToken: gatewayToken,\n          tokenExpirationMarginSeconds: tokenExpirationMarginSeconds\n        });\n        dispatch({\n          type: 'refresh_complete'\n        });\n      }, checkForExpirationIntervalMilliseconds); // this will be cleared on completion\n\n      logDebug('Setting token refresh timeout', {\n        expiring: gatewayToken.expiryTime,\n        checkForExpirationIntervalMilliseconds: checkForExpirationIntervalMilliseconds,\n        margin: tokenExpirationMarginSeconds\n      });\n      dispatch({\n        type: 'refresh_set_timeout',\n        refreshTimeoutId: timeoutId\n      });\n    }\n  }, [refreshTimeoutId, stage, gatewayToken, networkConfig.tokenExpirationMarginSeconds]);\n  /**\n   * use the passed proof of wallet ownership string to call the gatekeeper refresh token\n   * endpoint.\n   * On server error (5xx), retry with backoff.\n   * On all other errors, e.g. 400, move to a REFRESH_FAILED state.\n   */\n\n  var refreshToken = (0, react_1.useCallback)(function (useWallet) {\n    return /*#__PURE__*/function () {\n      var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(_ref2) {\n        var proof, payload, refreshResult;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                proof = _ref2.proof, payload = _ref2.payload;\n                logDebug('Refresh token', {\n                  payload: payload,\n                  proof: proof\n                });\n                dispatch({\n                  type: 'refresh_with_powo_in_progress'\n                });\n                _context.next = 5;\n                return gatekeeperClient().refreshToken({\n                  wallet: useWallet,\n                  payload: payload,\n                  proof: proof,\n                  ownerSigns: ownerSigns !== null && ownerSigns !== void 0 ? ownerSigns : false\n                });\n\n              case 5:\n                refreshResult = _context.sent;\n                dispatch({\n                  type: 'refresh_token_success'\n                });\n                return _context.abrupt(\"return\", refreshResult.transaction);\n\n              case 8:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      return function (_x) {\n        return _ref3.apply(this, arguments);\n      };\n    }();\n  }, [gatewayToken, gatekeeperClient, checkForRefreshWithTimeout, ownerSigns, walletAddress]);\n  /**\n   * wait until a gateway token exists in state before resolving the promise\n   */\n\n  var waitForUnexpiredGatewayToken = (0, react_1.useCallback)(function () {\n    return new Promise(function (resolve, reject) {\n      logDebug('Waiting for unexpired token');\n\n      if (setTimeoutForRefresh.current) {\n        logDebug('Clearing interval for gatewayToken', setTimeoutForRefresh.current);\n        clearTimeout(setTimeoutForRefresh.current);\n        setTimeoutForRefresh.current = null;\n      }\n\n      var isExpired = (gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.expiryTime) && (0, tokenUtils_1.hasExpired)(gatewayToken.expiryTime);\n\n      if (!isExpired) {\n        logDebug('Gateway token is unexpired', gatewayToken);\n        resolve();\n        return;\n      }\n\n      setTimeoutForRefresh.current = setTimeout(function () {\n        reject(new Error('Gateway token refresh has not been updated onChain'));\n      }, networkConfig.waitForTokenRefreshTimoutMilliseconds);\n      logDebug('Starting check for Gateway token expiration timeout with identifier', setTimeoutForRefresh.current);\n    });\n  }, [gatewayToken, setTimeoutForRefresh, gatekeeperNetworkAddress]);\n  return {\n    checkForRefreshWithTimeout: checkForRefreshWithTimeout,\n    refreshToken: refreshToken,\n    waitForUnexpiredGatewayToken: waitForUnexpiredGatewayToken\n  };\n};\n\nexports.default = useRefresh;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","reducer","react_1","require","utils_1","logger_1","types_1","tokenUtils_1","state","action","type","assign","walletPowoInProgress","powoFinished","powoRequested","undefined","refreshInProgress","gatewayStatus","GatewayStatus","REFRESH_TOKEN_REQUIRED","refreshTokenState","RefreshTokenState","IN_PROGRESS","COMPLETED","statusFromToken","gatewayToken","refreshTimeoutId","civicPass","responsePayload","FAILED","renderIframe","iframeMinimized","CHECKING","WAIT_FOR_ON_CHAIN","useRefresh","dispatch","stage","gatekeeperClient","networkConfig","gatekeeperNetworkAddress","ownerSigns","walletAddress","logDebug","message","obj","default","debug","setTimeoutForRefresh","useRef","checkForRefreshWithTimeout","useCallback","expiryTime","tokenExpirationMarginSeconds","checkForExpirationIntervalMilliseconds","getTokenRefreshIntervalMilliseconds","timeoutId","setTimeout","shouldRefresh","isTokenRefreshRequired","expiring","margin","refreshToken","useWallet","proof","payload","wallet","refreshResult","transaction","waitForUnexpiredGatewayToken","Promise","resolve","reject","current","clearTimeout","isExpired","hasExpired","Error","waitForTokenRefreshTimoutMilliseconds"],"sources":["/Users/nikola/Sites/candy-machine/candy-machine-ui/node_modules/@civic/solana-gateway-react/dist/esm/useHooks/useRefresh.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.reducer = void 0;\nconst react_1 = require(\"react\");\nconst utils_1 = require(\"../useReducer/utils\");\nconst logger_1 = __importDefault(require(\"../logger\"));\nconst types_1 = require(\"../types\");\nconst tokenUtils_1 = require(\"../utils/tokenUtils\");\nconst reducer = (state, action) => {\n    switch (action.type) {\n        case 'refresh_start': {\n            return Object.assign(Object.assign({}, state), { walletPowoInProgress: false, powoFinished: false, powoRequested: undefined, refreshInProgress: true, gatewayStatus: types_1.GatewayStatus.REFRESH_TOKEN_REQUIRED });\n        }\n        case 'refresh_status_check': {\n            return Object.assign(Object.assign({}, state), { refreshTokenState: types_1.RefreshTokenState.IN_PROGRESS });\n        }\n        case 'refresh_complete': {\n            return Object.assign(Object.assign({}, state), { refreshTokenState: types_1.RefreshTokenState.COMPLETED, gatewayStatus: (0, utils_1.statusFromToken)(state, state.gatewayToken), refreshTimeoutId: undefined, civicPass: Object.assign(Object.assign({}, state.civicPass), { responsePayload: undefined }) });\n        }\n        case 'refresh_failed': {\n            return Object.assign(Object.assign({}, state), { refreshTokenState: types_1.RefreshTokenState.FAILED, gatewayStatus: (0, utils_1.statusFromToken)(state, state.gatewayToken), civicPass: Object.assign(Object.assign({}, state.civicPass), { responsePayload: undefined }) });\n        }\n        case 'refresh_with_powo_in_progress': {\n            return Object.assign(Object.assign({}, state), { renderIframe: false, iframeMinimized: true, gatewayStatus: types_1.GatewayStatus.CHECKING });\n        }\n        case 'refresh_clear_timeout':\n            return Object.assign(Object.assign({}, state), { refreshTimeoutId: undefined });\n        case 'refresh_set_timeout':\n            return Object.assign(Object.assign({}, state), { refreshTimeoutId: action.refreshTimeoutId });\n        case 'refresh_token_success':\n            return Object.assign(Object.assign({}, state), { refreshTokenState: types_1.RefreshTokenState.WAIT_FOR_ON_CHAIN });\n        default:\n            return state;\n    }\n};\nexports.reducer = reducer;\nconst useRefresh = ({ stage, gatekeeperClient, networkConfig, }, state, dispatch) => {\n    const { refreshTimeoutId, gatewayToken, gatekeeperNetworkAddress, ownerSigns, walletAddress } = state;\n    const logDebug = (message, obj = null) => logger_1.default.debug(`[useRefresh] ${message}`, obj);\n    const setTimeoutForRefresh = (0, react_1.useRef)(null);\n    /**\n     * Start a timeout based on the expiration of the GatewayToken that will check if a token needs to be refreshed\n     * event, triggering the refreshFlow\n     */\n    const checkForRefreshWithTimeout = (0, react_1.useCallback)(() => {\n        logDebug('Checking if refresh required', refreshTimeoutId);\n        dispatch({ type: 'refresh_status_check' });\n        if (!refreshTimeoutId && (gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.expiryTime)) {\n            const { tokenExpirationMarginSeconds } = networkConfig;\n            const checkForExpirationIntervalMilliseconds = (0, tokenUtils_1.getTokenRefreshIntervalMilliseconds)(gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.expiryTime, tokenExpirationMarginSeconds);\n            const timeoutId = setTimeout(() => {\n                const shouldRefresh = (0, tokenUtils_1.isTokenRefreshRequired)({ gatewayToken, tokenExpirationMarginSeconds });\n                if (shouldRefresh) {\n                    logDebug('Refreshing Gateway Token');\n                    dispatch({ type: 'refresh_start' });\n                    dispatch({ type: 'civicPass_check_token_status' });\n                    return;\n                }\n                logDebug('Skipping refresh', { gatewayToken, tokenExpirationMarginSeconds });\n                dispatch({ type: 'refresh_complete' });\n            }, checkForExpirationIntervalMilliseconds); // this will be cleared on completion\n            logDebug('Setting token refresh timeout', {\n                expiring: gatewayToken.expiryTime,\n                checkForExpirationIntervalMilliseconds,\n                margin: tokenExpirationMarginSeconds,\n            });\n            dispatch({\n                type: 'refresh_set_timeout',\n                refreshTimeoutId: timeoutId,\n            });\n        }\n    }, [refreshTimeoutId, stage, gatewayToken, networkConfig.tokenExpirationMarginSeconds]);\n    /**\n     * use the passed proof of wallet ownership string to call the gatekeeper refresh token\n     * endpoint.\n     * On server error (5xx), retry with backoff.\n     * On all other errors, e.g. 400, move to a REFRESH_FAILED state.\n     */\n    const refreshToken = (0, react_1.useCallback)((useWallet) => async ({ proof, payload }) => {\n        logDebug('Refresh token', { payload, proof });\n        dispatch({ type: 'refresh_with_powo_in_progress' });\n        const refreshResult = await gatekeeperClient().refreshToken({\n            wallet: useWallet,\n            payload,\n            proof,\n            ownerSigns: ownerSigns !== null && ownerSigns !== void 0 ? ownerSigns : false,\n        });\n        dispatch({ type: 'refresh_token_success' });\n        return refreshResult.transaction;\n    }, [gatewayToken, gatekeeperClient, checkForRefreshWithTimeout, ownerSigns, walletAddress]);\n    /**\n     * wait until a gateway token exists in state before resolving the promise\n     */\n    const waitForUnexpiredGatewayToken = (0, react_1.useCallback)(() => {\n        return new Promise((resolve, reject) => {\n            logDebug('Waiting for unexpired token');\n            if (setTimeoutForRefresh.current) {\n                logDebug('Clearing interval for gatewayToken', setTimeoutForRefresh.current);\n                clearTimeout(setTimeoutForRefresh.current);\n                setTimeoutForRefresh.current = null;\n            }\n            const isExpired = (gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.expiryTime) && (0, tokenUtils_1.hasExpired)(gatewayToken.expiryTime);\n            if (!isExpired) {\n                logDebug('Gateway token is unexpired', gatewayToken);\n                resolve();\n                return;\n            }\n            setTimeoutForRefresh.current = setTimeout(() => {\n                reject(new Error('Gateway token refresh has not been updated onChain'));\n            }, networkConfig.waitForTokenRefreshTimoutMilliseconds);\n            logDebug('Starting check for Gateway token expiration timeout with identifier', setTimeoutForRefresh.current);\n        });\n    }, [gatewayToken, setTimeoutForRefresh, gatekeeperNetworkAddress]);\n    return {\n        checkForRefreshWithTimeout,\n        refreshToken,\n        waitForUnexpiredGatewayToken,\n    };\n};\nexports.default = useRefresh;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}