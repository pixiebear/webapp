{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.reducer = void 0;\n\nconst react_1 = require(\"react\");\n\nconst utils_1 = require(\"../useReducer/utils\");\n\nconst logger_1 = __importDefault(require(\"../logger\"));\n\nconst types_1 = require(\"../types\");\n\nconst tokenUtils_1 = require(\"../utils/tokenUtils\");\n\nconst reducer = (state, action) => {\n  switch (action.type) {\n    case 'refresh_start':\n      {\n        return Object.assign(Object.assign({}, state), {\n          walletPowoInProgress: false,\n          powoFinished: false,\n          powoRequested: undefined,\n          refreshInProgress: true,\n          gatewayStatus: types_1.GatewayStatus.REFRESH_TOKEN_REQUIRED\n        });\n      }\n\n    case 'refresh_status_check':\n      {\n        return Object.assign(Object.assign({}, state), {\n          refreshTokenState: types_1.RefreshTokenState.IN_PROGRESS\n        });\n      }\n\n    case 'refresh_complete':\n      {\n        return Object.assign(Object.assign({}, state), {\n          refreshTokenState: types_1.RefreshTokenState.COMPLETED,\n          gatewayStatus: (0, utils_1.statusFromToken)(state, state.gatewayToken),\n          refreshTimeoutId: undefined,\n          civicPass: Object.assign(Object.assign({}, state.civicPass), {\n            responsePayload: undefined\n          })\n        });\n      }\n\n    case 'refresh_failed':\n      {\n        return Object.assign(Object.assign({}, state), {\n          refreshTokenState: types_1.RefreshTokenState.FAILED,\n          gatewayStatus: (0, utils_1.statusFromToken)(state, state.gatewayToken),\n          civicPass: Object.assign(Object.assign({}, state.civicPass), {\n            responsePayload: undefined\n          })\n        });\n      }\n\n    case 'refresh_with_powo_in_progress':\n      {\n        return Object.assign(Object.assign({}, state), {\n          renderIframe: false,\n          iframeMinimized: true,\n          gatewayStatus: types_1.GatewayStatus.CHECKING\n        });\n      }\n\n    case 'refresh_clear_timeout':\n      return Object.assign(Object.assign({}, state), {\n        refreshTimeoutId: undefined\n      });\n\n    case 'refresh_set_timeout':\n      return Object.assign(Object.assign({}, state), {\n        refreshTimeoutId: action.refreshTimeoutId\n      });\n\n    case 'refresh_token_success':\n      return Object.assign(Object.assign({}, state), {\n        refreshTokenState: types_1.RefreshTokenState.WAIT_FOR_ON_CHAIN\n      });\n\n    default:\n      return state;\n  }\n};\n\nexports.reducer = reducer;\n\nconst useRefresh = (_ref, state, dispatch) => {\n  let {\n    stage,\n    gatekeeperClient,\n    networkConfig\n  } = _ref;\n  const {\n    refreshTimeoutId,\n    gatewayToken,\n    gatekeeperNetworkAddress,\n    ownerSigns,\n    walletAddress\n  } = state;\n\n  const logDebug = function (message) {\n    let obj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return logger_1.default.debug(`[useRefresh] ${message}`, obj);\n  };\n\n  const setTimeoutForRefresh = (0, react_1.useRef)(null);\n  /**\n   * Start a timeout based on the expiration of the GatewayToken that will check if a token needs to be refreshed\n   * event, triggering the refreshFlow\n   */\n\n  const checkForRefreshWithTimeout = (0, react_1.useCallback)(() => {\n    logDebug('Checking if refresh required', refreshTimeoutId);\n    dispatch({\n      type: 'refresh_status_check'\n    });\n\n    if (!refreshTimeoutId && (gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.expiryTime)) {\n      const {\n        tokenExpirationMarginSeconds\n      } = networkConfig;\n      const checkForExpirationIntervalMilliseconds = (0, tokenUtils_1.getTokenRefreshIntervalMilliseconds)(gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.expiryTime, tokenExpirationMarginSeconds);\n      const timeoutId = setTimeout(() => {\n        const shouldRefresh = (0, tokenUtils_1.isTokenRefreshRequired)({\n          gatewayToken,\n          tokenExpirationMarginSeconds\n        });\n\n        if (shouldRefresh) {\n          logDebug('Refreshing Gateway Token');\n          dispatch({\n            type: 'refresh_start'\n          });\n          dispatch({\n            type: 'civicPass_check_token_status'\n          });\n          return;\n        }\n\n        logDebug('Skipping refresh', {\n          gatewayToken,\n          tokenExpirationMarginSeconds\n        });\n        dispatch({\n          type: 'refresh_complete'\n        });\n      }, checkForExpirationIntervalMilliseconds); // this will be cleared on completion\n\n      logDebug('Setting token refresh timeout', {\n        expiring: gatewayToken.expiryTime,\n        checkForExpirationIntervalMilliseconds,\n        margin: tokenExpirationMarginSeconds\n      });\n      dispatch({\n        type: 'refresh_set_timeout',\n        refreshTimeoutId: timeoutId\n      });\n    }\n  }, [refreshTimeoutId, stage, gatewayToken, networkConfig.tokenExpirationMarginSeconds]);\n  /**\n   * use the passed proof of wallet ownership string to call the gatekeeper refresh token\n   * endpoint.\n   * On server error (5xx), retry with backoff.\n   * On all other errors, e.g. 400, move to a REFRESH_FAILED state.\n   */\n\n  const refreshToken = (0, react_1.useCallback)(useWallet => async _ref2 => {\n    let {\n      proof,\n      payload\n    } = _ref2;\n    logDebug('Refresh token', {\n      payload,\n      proof\n    });\n    dispatch({\n      type: 'refresh_with_powo_in_progress'\n    });\n    const refreshResult = await gatekeeperClient().refreshToken({\n      wallet: useWallet,\n      payload,\n      proof,\n      ownerSigns: ownerSigns !== null && ownerSigns !== void 0 ? ownerSigns : false\n    });\n    dispatch({\n      type: 'refresh_token_success'\n    });\n    return refreshResult.transaction;\n  }, [gatewayToken, gatekeeperClient, checkForRefreshWithTimeout, ownerSigns, walletAddress]);\n  /**\n   * wait until a gateway token exists in state before resolving the promise\n   */\n\n  const waitForUnexpiredGatewayToken = (0, react_1.useCallback)(() => {\n    return new Promise((resolve, reject) => {\n      logDebug('Waiting for unexpired token');\n\n      if (setTimeoutForRefresh.current) {\n        logDebug('Clearing interval for gatewayToken', setTimeoutForRefresh.current);\n        clearTimeout(setTimeoutForRefresh.current);\n        setTimeoutForRefresh.current = null;\n      }\n\n      const isExpired = (gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.expiryTime) && (0, tokenUtils_1.hasExpired)(gatewayToken.expiryTime);\n\n      if (!isExpired) {\n        logDebug('Gateway token is unexpired', gatewayToken);\n        resolve();\n        return;\n      }\n\n      setTimeoutForRefresh.current = setTimeout(() => {\n        reject(new Error('Gateway token refresh has not been updated onChain'));\n      }, networkConfig.waitForTokenRefreshTimoutMilliseconds);\n      logDebug('Starting check for Gateway token expiration timeout with identifier', setTimeoutForRefresh.current);\n    });\n  }, [gatewayToken, setTimeoutForRefresh, gatekeeperNetworkAddress]);\n  return {\n    checkForRefreshWithTimeout,\n    refreshToken,\n    waitForUnexpiredGatewayToken\n  };\n};\n\nexports.default = useRefresh;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","reducer","react_1","require","utils_1","logger_1","types_1","tokenUtils_1","state","action","type","assign","walletPowoInProgress","powoFinished","powoRequested","undefined","refreshInProgress","gatewayStatus","GatewayStatus","REFRESH_TOKEN_REQUIRED","refreshTokenState","RefreshTokenState","IN_PROGRESS","COMPLETED","statusFromToken","gatewayToken","refreshTimeoutId","civicPass","responsePayload","FAILED","renderIframe","iframeMinimized","CHECKING","WAIT_FOR_ON_CHAIN","useRefresh","dispatch","stage","gatekeeperClient","networkConfig","gatekeeperNetworkAddress","ownerSigns","walletAddress","logDebug","message","obj","default","debug","setTimeoutForRefresh","useRef","checkForRefreshWithTimeout","useCallback","expiryTime","tokenExpirationMarginSeconds","checkForExpirationIntervalMilliseconds","getTokenRefreshIntervalMilliseconds","timeoutId","setTimeout","shouldRefresh","isTokenRefreshRequired","expiring","margin","refreshToken","useWallet","proof","payload","refreshResult","wallet","transaction","waitForUnexpiredGatewayToken","Promise","resolve","reject","current","clearTimeout","isExpired","hasExpired","Error","waitForTokenRefreshTimoutMilliseconds"],"sources":["/Users/nikola/Sites/candy-machine/candy-machine-ui/node_modules/@civic/solana-gateway-react/dist/esm/useHooks/useRefresh.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.reducer = void 0;\nconst react_1 = require(\"react\");\nconst utils_1 = require(\"../useReducer/utils\");\nconst logger_1 = __importDefault(require(\"../logger\"));\nconst types_1 = require(\"../types\");\nconst tokenUtils_1 = require(\"../utils/tokenUtils\");\nconst reducer = (state, action) => {\n    switch (action.type) {\n        case 'refresh_start': {\n            return Object.assign(Object.assign({}, state), { walletPowoInProgress: false, powoFinished: false, powoRequested: undefined, refreshInProgress: true, gatewayStatus: types_1.GatewayStatus.REFRESH_TOKEN_REQUIRED });\n        }\n        case 'refresh_status_check': {\n            return Object.assign(Object.assign({}, state), { refreshTokenState: types_1.RefreshTokenState.IN_PROGRESS });\n        }\n        case 'refresh_complete': {\n            return Object.assign(Object.assign({}, state), { refreshTokenState: types_1.RefreshTokenState.COMPLETED, gatewayStatus: (0, utils_1.statusFromToken)(state, state.gatewayToken), refreshTimeoutId: undefined, civicPass: Object.assign(Object.assign({}, state.civicPass), { responsePayload: undefined }) });\n        }\n        case 'refresh_failed': {\n            return Object.assign(Object.assign({}, state), { refreshTokenState: types_1.RefreshTokenState.FAILED, gatewayStatus: (0, utils_1.statusFromToken)(state, state.gatewayToken), civicPass: Object.assign(Object.assign({}, state.civicPass), { responsePayload: undefined }) });\n        }\n        case 'refresh_with_powo_in_progress': {\n            return Object.assign(Object.assign({}, state), { renderIframe: false, iframeMinimized: true, gatewayStatus: types_1.GatewayStatus.CHECKING });\n        }\n        case 'refresh_clear_timeout':\n            return Object.assign(Object.assign({}, state), { refreshTimeoutId: undefined });\n        case 'refresh_set_timeout':\n            return Object.assign(Object.assign({}, state), { refreshTimeoutId: action.refreshTimeoutId });\n        case 'refresh_token_success':\n            return Object.assign(Object.assign({}, state), { refreshTokenState: types_1.RefreshTokenState.WAIT_FOR_ON_CHAIN });\n        default:\n            return state;\n    }\n};\nexports.reducer = reducer;\nconst useRefresh = ({ stage, gatekeeperClient, networkConfig, }, state, dispatch) => {\n    const { refreshTimeoutId, gatewayToken, gatekeeperNetworkAddress, ownerSigns, walletAddress } = state;\n    const logDebug = (message, obj = null) => logger_1.default.debug(`[useRefresh] ${message}`, obj);\n    const setTimeoutForRefresh = (0, react_1.useRef)(null);\n    /**\n     * Start a timeout based on the expiration of the GatewayToken that will check if a token needs to be refreshed\n     * event, triggering the refreshFlow\n     */\n    const checkForRefreshWithTimeout = (0, react_1.useCallback)(() => {\n        logDebug('Checking if refresh required', refreshTimeoutId);\n        dispatch({ type: 'refresh_status_check' });\n        if (!refreshTimeoutId && (gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.expiryTime)) {\n            const { tokenExpirationMarginSeconds } = networkConfig;\n            const checkForExpirationIntervalMilliseconds = (0, tokenUtils_1.getTokenRefreshIntervalMilliseconds)(gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.expiryTime, tokenExpirationMarginSeconds);\n            const timeoutId = setTimeout(() => {\n                const shouldRefresh = (0, tokenUtils_1.isTokenRefreshRequired)({ gatewayToken, tokenExpirationMarginSeconds });\n                if (shouldRefresh) {\n                    logDebug('Refreshing Gateway Token');\n                    dispatch({ type: 'refresh_start' });\n                    dispatch({ type: 'civicPass_check_token_status' });\n                    return;\n                }\n                logDebug('Skipping refresh', { gatewayToken, tokenExpirationMarginSeconds });\n                dispatch({ type: 'refresh_complete' });\n            }, checkForExpirationIntervalMilliseconds); // this will be cleared on completion\n            logDebug('Setting token refresh timeout', {\n                expiring: gatewayToken.expiryTime,\n                checkForExpirationIntervalMilliseconds,\n                margin: tokenExpirationMarginSeconds,\n            });\n            dispatch({\n                type: 'refresh_set_timeout',\n                refreshTimeoutId: timeoutId,\n            });\n        }\n    }, [refreshTimeoutId, stage, gatewayToken, networkConfig.tokenExpirationMarginSeconds]);\n    /**\n     * use the passed proof of wallet ownership string to call the gatekeeper refresh token\n     * endpoint.\n     * On server error (5xx), retry with backoff.\n     * On all other errors, e.g. 400, move to a REFRESH_FAILED state.\n     */\n    const refreshToken = (0, react_1.useCallback)((useWallet) => async ({ proof, payload }) => {\n        logDebug('Refresh token', { payload, proof });\n        dispatch({ type: 'refresh_with_powo_in_progress' });\n        const refreshResult = await gatekeeperClient().refreshToken({\n            wallet: useWallet,\n            payload,\n            proof,\n            ownerSigns: ownerSigns !== null && ownerSigns !== void 0 ? ownerSigns : false,\n        });\n        dispatch({ type: 'refresh_token_success' });\n        return refreshResult.transaction;\n    }, [gatewayToken, gatekeeperClient, checkForRefreshWithTimeout, ownerSigns, walletAddress]);\n    /**\n     * wait until a gateway token exists in state before resolving the promise\n     */\n    const waitForUnexpiredGatewayToken = (0, react_1.useCallback)(() => {\n        return new Promise((resolve, reject) => {\n            logDebug('Waiting for unexpired token');\n            if (setTimeoutForRefresh.current) {\n                logDebug('Clearing interval for gatewayToken', setTimeoutForRefresh.current);\n                clearTimeout(setTimeoutForRefresh.current);\n                setTimeoutForRefresh.current = null;\n            }\n            const isExpired = (gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.expiryTime) && (0, tokenUtils_1.hasExpired)(gatewayToken.expiryTime);\n            if (!isExpired) {\n                logDebug('Gateway token is unexpired', gatewayToken);\n                resolve();\n                return;\n            }\n            setTimeoutForRefresh.current = setTimeout(() => {\n                reject(new Error('Gateway token refresh has not been updated onChain'));\n            }, networkConfig.waitForTokenRefreshTimoutMilliseconds);\n            logDebug('Starting check for Gateway token expiration timeout with identifier', setTimeoutForRefresh.current);\n        });\n    }, [gatewayToken, setTimeoutForRefresh, gatekeeperNetworkAddress]);\n    return {\n        checkForRefreshWithTimeout,\n        refreshToken,\n        waitForUnexpiredGatewayToken,\n    };\n};\nexports.default = useRefresh;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}