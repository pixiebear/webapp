{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/nikola/Sites/candy-machine/candy-machine-ui/node_modules/@babel/runtime/regenerator/index.js\");\n\nvar _asyncToGenerator = require(\"/Users/nikola/Sites/candy-machine/candy-machine-ui/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar react_1 = require(\"react\");\n\nvar config_1 = require(\"../solana/config\");\n\nvar logger_1 = __importDefault(require(\"../logger\"));\n\nvar types_1 = require(\"../types\");\n\nvar useChain_1 = __importDefault(require(\"./useChain\"));\n\nvar useRefresh_1 = __importDefault(require(\"./useRefresh\"));\n\nvar useWalletHooks_1 = __importDefault(require(\"./useWalletHooks\"));\n\nvar actionCreator_1 = require(\"../actionCreator\");\n\nvar usePOWO_1 = __importDefault(require(\"./usePOWO\"));\n\nvar useGatekeeper_1 = __importDefault(require(\"./useGatekeeper\"));\n\nvar useGatekeeperRecord_1 = __importDefault(require(\"./useGatekeeperRecord\"));\n\nvar networkConfig_1 = __importDefault(require(\"../networkConfig\"));\n\nvar useCivicPass_1 = __importDefault(require(\"./useCivicPass\"));\n\nvar useCivicPassEventListener_1 = __importDefault(require(\"./useCivicPassEventListener\"));\n/**\n * The orchestrator hook handles the main business logic of the component handling 2 main scenarios:\n * 1. the creation of a new gateway token for a new user\n * 2. the refreshing of an existing token for an existing user\n *\n * The orchestrator triggers uses effects to trigger flows for these two scenarios\n *\n * @param {{ wallet: WalletAdapter | undefined; clusterUrl: string; gatekeeperNetworkAddress: string | undefined; stage: string }} param0\n * @param {Partial<RootState>} state\n * @param {React.Dispatch<Action>} dispatch\n * @returns void\n */\n\n\nvar useOrchestration = function useOrchestration(_ref, state, dispatch) {\n  var wallet = _ref.wallet,\n      stage = _ref.stage,\n      chainImplementation = _ref.chainImplementation,\n      gatekeeperClient = _ref.gatekeeperClient;\n\n  var _ref2 = (0, useWalletHooks_1.default)(wallet, state, dispatch),\n      expectWalletConnected = _ref2.expectWalletConnected;\n\n  var gatekeeperEndpoint = (0, config_1.getGatekeeperEndpoint)(stage);\n  var gatewayToken = state.gatewayToken,\n      walletToRefresh = state.walletToRefresh,\n      civicPass = state.civicPass,\n      refreshTokenState = state.refreshTokenState,\n      gatewayStatus = state.gatewayStatus,\n      gatekeeperNetworkAddress = state.gatekeeperNetworkAddress,\n      ownerSigns = state.ownerSigns,\n      renderIframe = state.renderIframe,\n      refreshTimeoutId = state.refreshTimeoutId;\n  var networkConfig = (0, networkConfig_1.default)({\n    gatekeeperNetworkAddress: gatekeeperNetworkAddress,\n    stage: stage\n  }); // Register our hooks here\n\n  var _ref3 = (0, usePOWO_1.default)({\n    wallet: wallet,\n    chainImplementation: chainImplementation\n  }, state, dispatch),\n      waitForConfirmPOWO = _ref3.waitForConfirmPOWO,\n      waitForPOWO = _ref3.waitForPOWO,\n      waitForHandleTransaction = _ref3.waitForHandleTransaction;\n\n  var _ref4 = (0, useGatekeeper_1.default)({\n    wallet: wallet,\n    stage: stage,\n    gatekeeperClient: gatekeeperClient\n  }, state, dispatch),\n      waitForGatekeeperIssuanceRequest = _ref4.waitForGatekeeperIssuanceRequest;\n\n  var _ref5 = (0, useRefresh_1.default)({\n    stage: stage,\n    gatekeeperClient: gatekeeperClient,\n    networkConfig: networkConfig\n  }, state, dispatch),\n      checkForRefreshWithTimeout = _ref5.checkForRefreshWithTimeout,\n      refreshToken = _ref5.refreshToken,\n      waitForUnexpiredGatewayToken = _ref5.waitForUnexpiredGatewayToken;\n\n  (0, useCivicPass_1.default)({\n    wallet: wallet\n  }, state, dispatch);\n  (0, useCivicPassEventListener_1.default)({\n    wallet: wallet,\n    chainImplementation: chainImplementation\n  });\n  (0, useChain_1.default)({\n    wallet: wallet,\n    chainImplementation: chainImplementation,\n    networkConfig: networkConfig\n  }, state, dispatch);\n  (0, useGatekeeperRecord_1.default)({\n    wallet: wallet,\n    gatekeeperClient: gatekeeperClient,\n    httpConfig: chainImplementation.httpConfig,\n    networkConfig: networkConfig\n  }, state, dispatch);\n  /**\n   * Refresh Flows ----------------------------------------------------------------\n   */\n\n  /**\n   * wait until we have a payload that has been emitted by the CivicPass iframe\n   * then resolve the promise\n   */\n\n  var waitForCivicPassRefreshResponsePayload = (0, react_1.useCallback)(function () {\n    expectWalletConnected();\n    logger_1.default.debug('waitForCivicPassRefreshResponsePayload');\n    var result = new Promise(function (resolve) {\n      var responsePayload = civicPass === null || civicPass === void 0 ? void 0 : civicPass.responsePayload;\n      var refreshPayload = responsePayload && responsePayload[types_1.CivicPassMessageAction.REFRESH];\n      logger_1.default.debug('Refresh payload...', {\n        refreshPayload: refreshPayload,\n        refreshPayloadState: refreshPayload === undefined\n      });\n\n      if (refreshPayload !== undefined) {\n        logger_1.default.debug('Refreshing token...');\n        resolve(refreshPayload);\n      }\n    });\n    return result;\n  }, [civicPass === null || civicPass === void 0 ? void 0 : civicPass.responsePayload, expectWalletConnected]);\n  /**\n   * When we have a token start check the next expiration so we can prompt the user to refresh\n   */\n\n  (0, react_1.useEffect)(function () {\n    if (gatewayStatus === types_1.GatewayStatus.ACTIVE || refreshTokenState === types_1.RefreshTokenState.COMPLETED) {\n      logger_1.default.debug('Start polling for the refresh interval');\n      checkForRefreshWithTimeout(wallet);\n    }\n  }, [gatewayStatus, refreshTokenState, wallet, renderIframe]);\n  /**\n   * Whenever the iFrame is rendered, clear the timeout\n   */\n\n  (0, react_1.useEffect)(function () {\n    if (renderIframe && refreshTimeoutId) {\n      clearTimeout(refreshTimeoutId);\n      dispatch({\n        type: 'refresh_clear_timeout'\n      });\n    }\n  }, [renderIframe, refreshTimeoutId]);\n  /**\n   * Issuance Flows ----------------------------------------------------------------\n   */\n\n  /**\n   * poll until a gatekeeper record is found, once active check the chain for a token\n   * then dispatch a tokenChange event that will result in the token getting saved to state\n   * start token refresh polling once a valid token is set\n   */\n\n  var waitForOnChainToken = (0, react_1.useCallback)( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n    var actionCreator;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (!wallet) {\n              _context.next = 5;\n              break;\n            }\n\n            logger_1.default.debug('waitForOnChainToken');\n            actionCreator = (0, actionCreator_1.gatewayTokenActionCreator)({\n              wallet: wallet,\n              chainImplementation: chainImplementation,\n              gatekeeperClient: gatekeeperClient,\n              dispatch: dispatch,\n              networkConfig: networkConfig\n            });\n            _context.next = 5;\n            return actionCreator.waitForGatewayToken();\n\n          case 5:\n            return _context.abrupt(\"return\", null);\n\n          case 6:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  })), [gatekeeperEndpoint, gatekeeperClient, expectWalletConnected]);\n  /**\n   * wait until a presentation request id has been emitted by the CivicPass iframe\n   * then resolve the promise\n   */\n\n  var waitForCivicPassIssuanceResponsePayload = (0, react_1.useCallback)(function () {\n    expectWalletConnected();\n    logger_1.default.debug('waitForCivicPassIssuanceResponsePayload');\n    var result = new Promise(function (resolve) {\n      var responsePayload = civicPass === null || civicPass === void 0 ? void 0 : civicPass.responsePayload;\n      var issuancePayload = responsePayload && responsePayload[types_1.CivicPassMessageAction.ISSUANCE];\n      logger_1.default.debug('Issuance payload...', issuancePayload);\n\n      if (issuancePayload !== undefined) {\n        resolve(issuancePayload);\n      }\n    });\n    return result;\n  }, [civicPass === null || civicPass === void 0 ? void 0 : civicPass.responsePayload, expectWalletConnected]);\n  /**\n   * wait until the user has requested a gateway token before resolving the promise\n   */\n\n  var checkForRequiredProof = (0, react_1.useCallback)( /*#__PURE__*/function () {\n    var _ref8 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(_ref7) {\n      var requiresProofOfWalletOwnership, payload, result;\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              requiresProofOfWalletOwnership = _ref7.requiresProofOfWalletOwnership, payload = _ref7.payload;\n              logger_1.default.debug('Checking for required proof', {\n                requiresProofOfWalletOwnership: requiresProofOfWalletOwnership,\n                payload: payload\n              });\n\n              if (!requiresProofOfWalletOwnership) {\n                _context2.next = 7;\n                break;\n              }\n\n              _context2.next = 5;\n              return waitForConfirmPOWO(payload).then(waitForPOWO);\n\n            case 5:\n              result = _context2.sent;\n              return _context2.abrupt(\"return\", result);\n\n            case 7:\n              return _context2.abrupt(\"return\", {\n                payload: payload\n              });\n\n            case 8:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n\n    return function (_x) {\n      return _ref8.apply(this, arguments);\n    };\n  }(), [waitForConfirmPOWO, waitForPOWO]);\n  /**\n   * New token request flow:\n   * wait for the user to request a new token\n   * wait for the iframe to return a payload\n   * wait for the user to confirm they've read the proof of ownership dialogue\n   * wait for the user to provide proof of ownership\n   * wait for a call to the gatekeeper to request a new token issuance\n   * wait for a gatekeeper record to be created\n   * once this flow is complete a new Gatekeeper token should be available and set in state\n   */\n\n  (0, react_1.useEffect)(function () {\n    if (!ownerSigns) {\n      waitForCivicPassIssuanceResponsePayload().then(checkForRequiredProof).then(waitForGatekeeperIssuanceRequest).then(waitForOnChainToken).then(function () {\n        return checkForRefreshWithTimeout(wallet);\n      }).catch(function (error) {\n        dispatch({\n          type: 'civicPass_issuance_failure'\n        });\n        logger_1.default.error('ERROR newTokenRequestFlow', error);\n      });\n    }\n  }, [waitForCivicPassIssuanceResponsePayload, checkForRequiredProof, waitForGatekeeperIssuanceRequest, waitForOnChainToken, ownerSigns]);\n  (0, react_1.useEffect)(function () {\n    if (ownerSigns) {\n      waitForCivicPassIssuanceResponsePayload().then(waitForGatekeeperIssuanceRequest).then(waitForHandleTransaction).then(waitForOnChainToken).then(function () {\n        return checkForRefreshWithTimeout(wallet);\n      }).catch(function (error) {\n        dispatch({\n          type: 'civicPass_issuance_failure'\n        });\n        logger_1.default.error('ERROR newTokenRequestFlow', error);\n      });\n    }\n  }, [waitForCivicPassIssuanceResponsePayload, checkForRequiredProof, waitForGatekeeperIssuanceRequest, waitForOnChainToken, ownerSigns]);\n  /**\n   * Refresh start flow:\n   * Triggered when we have a refreshResponse payload\n   * wait refresh to be triggered from the iFrame\n   * wait for the iframe to return a payload\n   * wait for the user to confirm they've read the proof of ownership dialogue\n   * wait for the user to provide proof of ownership\n   * wait for a call to the gatekeeper to refresh the token\n   * check if token is expired and timeout if token does not update within timeframe\n   */\n\n  (0, react_1.useEffect)(function () {\n    if (!ownerSigns) {\n      var useWallet = walletToRefresh || wallet;\n      waitForCivicPassRefreshResponsePayload().then(checkForRequiredProof).then(refreshToken(useWallet)).then(waitForUnexpiredGatewayToken).catch(function (error) {\n        logger_1.default.error('refreshFlow', error);\n        logger_1.default.error('refreshToken error', error);\n        dispatch({\n          type: 'refresh_failed'\n        });\n      });\n    }\n  }, [civicPass === null || civicPass === void 0 ? void 0 : civicPass.responsePayload, checkForRequiredProof, ownerSigns]);\n  (0, react_1.useEffect)(function () {\n    if (ownerSigns) {\n      var useWallet = walletToRefresh || wallet;\n      waitForCivicPassRefreshResponsePayload().then(refreshToken(useWallet)).then(waitForHandleTransaction).then(waitForUnexpiredGatewayToken).catch(function (error) {\n        logger_1.default.error('refreshFlow', error);\n        logger_1.default.error('refreshToken error', error);\n        dispatch({\n          type: 'refresh_failed'\n        });\n      });\n    }\n  }, [civicPass === null || civicPass === void 0 ? void 0 : civicPass.responsePayload, checkForRequiredProof, walletToRefresh, wallet, ownerSigns]);\n  /**\n   * Refresh complete flow:\n   * Triggered by token change event\n   * Check the refresh token state\n   * Check if token is unexpired and clear timeout if token is not expired\n   * Complete the refresh event and clear the refresh response payload\n   */\n\n  (0, react_1.useEffect)(function () {\n    var useWallet = walletToRefresh || wallet;\n\n    if (refreshTokenState === types_1.RefreshTokenState.WAIT_FOR_ON_CHAIN) {\n      waitForUnexpiredGatewayToken().then(function () {\n        return checkForRefreshWithTimeout(useWallet);\n      }).then(function () {\n        dispatch({\n          type: 'refresh_complete'\n        });\n      }).catch(function (error) {\n        logger_1.default.error('refreshFlow', error);\n        logger_1.default.error('refreshToken error', error);\n        dispatch({\n          type: 'refresh_failed'\n        });\n      });\n    }\n  }, [gatewayToken, refreshTokenState, walletToRefresh, wallet]);\n};\n\nexports.default = useOrchestration;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","react_1","require","config_1","logger_1","types_1","useChain_1","useRefresh_1","useWalletHooks_1","actionCreator_1","usePOWO_1","useGatekeeper_1","useGatekeeperRecord_1","networkConfig_1","useCivicPass_1","useCivicPassEventListener_1","useOrchestration","state","dispatch","wallet","stage","chainImplementation","gatekeeperClient","default","expectWalletConnected","gatekeeperEndpoint","getGatekeeperEndpoint","gatewayToken","walletToRefresh","civicPass","refreshTokenState","gatewayStatus","gatekeeperNetworkAddress","ownerSigns","renderIframe","refreshTimeoutId","networkConfig","waitForConfirmPOWO","waitForPOWO","waitForHandleTransaction","waitForGatekeeperIssuanceRequest","checkForRefreshWithTimeout","refreshToken","waitForUnexpiredGatewayToken","httpConfig","waitForCivicPassRefreshResponsePayload","useCallback","debug","result","Promise","resolve","responsePayload","refreshPayload","CivicPassMessageAction","REFRESH","refreshPayloadState","undefined","useEffect","GatewayStatus","ACTIVE","RefreshTokenState","COMPLETED","clearTimeout","type","waitForOnChainToken","actionCreator","gatewayTokenActionCreator","waitForGatewayToken","waitForCivicPassIssuanceResponsePayload","issuancePayload","ISSUANCE","checkForRequiredProof","requiresProofOfWalletOwnership","payload","then","catch","error","useWallet","WAIT_FOR_ON_CHAIN"],"sources":["/Users/nikola/Sites/candy-machine/candy-machine-ui/node_modules/@civic/solana-gateway-react/dist/esm/useHooks/useOrchestration.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst react_1 = require(\"react\");\nconst config_1 = require(\"../solana/config\");\nconst logger_1 = __importDefault(require(\"../logger\"));\nconst types_1 = require(\"../types\");\nconst useChain_1 = __importDefault(require(\"./useChain\"));\nconst useRefresh_1 = __importDefault(require(\"./useRefresh\"));\nconst useWalletHooks_1 = __importDefault(require(\"./useWalletHooks\"));\nconst actionCreator_1 = require(\"../actionCreator\");\nconst usePOWO_1 = __importDefault(require(\"./usePOWO\"));\nconst useGatekeeper_1 = __importDefault(require(\"./useGatekeeper\"));\nconst useGatekeeperRecord_1 = __importDefault(require(\"./useGatekeeperRecord\"));\nconst networkConfig_1 = __importDefault(require(\"../networkConfig\"));\nconst useCivicPass_1 = __importDefault(require(\"./useCivicPass\"));\nconst useCivicPassEventListener_1 = __importDefault(require(\"./useCivicPassEventListener\"));\n/**\n * The orchestrator hook handles the main business logic of the component handling 2 main scenarios:\n * 1. the creation of a new gateway token for a new user\n * 2. the refreshing of an existing token for an existing user\n *\n * The orchestrator triggers uses effects to trigger flows for these two scenarios\n *\n * @param {{ wallet: WalletAdapter | undefined; clusterUrl: string; gatekeeperNetworkAddress: string | undefined; stage: string }} param0\n * @param {Partial<RootState>} state\n * @param {React.Dispatch<Action>} dispatch\n * @returns void\n */\nconst useOrchestration = ({ wallet, stage, chainImplementation, gatekeeperClient, }, state, dispatch) => {\n    const { expectWalletConnected } = (0, useWalletHooks_1.default)(wallet, state, dispatch);\n    const gatekeeperEndpoint = (0, config_1.getGatekeeperEndpoint)(stage);\n    const { gatewayToken, walletToRefresh, civicPass, refreshTokenState, gatewayStatus, gatekeeperNetworkAddress, ownerSigns, renderIframe, refreshTimeoutId, } = state;\n    const networkConfig = (0, networkConfig_1.default)({ gatekeeperNetworkAddress, stage });\n    // Register our hooks here\n    const { waitForConfirmPOWO, waitForPOWO, waitForHandleTransaction } = (0, usePOWO_1.default)({ wallet, chainImplementation }, state, dispatch);\n    const { waitForGatekeeperIssuanceRequest } = (0, useGatekeeper_1.default)({ wallet, stage, gatekeeperClient }, state, dispatch);\n    const { checkForRefreshWithTimeout, refreshToken, waitForUnexpiredGatewayToken } = (0, useRefresh_1.default)({ stage, gatekeeperClient, networkConfig }, state, dispatch);\n    (0, useCivicPass_1.default)({ wallet }, state, dispatch);\n    (0, useCivicPassEventListener_1.default)({ wallet, chainImplementation });\n    (0, useChain_1.default)({ wallet, chainImplementation, networkConfig }, state, dispatch);\n    (0, useGatekeeperRecord_1.default)({ wallet, gatekeeperClient, httpConfig: chainImplementation.httpConfig, networkConfig }, state, dispatch);\n    /**\n     * Refresh Flows ----------------------------------------------------------------\n     */\n    /**\n     * wait until we have a payload that has been emitted by the CivicPass iframe\n     * then resolve the promise\n     */\n    const waitForCivicPassRefreshResponsePayload = (0, react_1.useCallback)(() => {\n        expectWalletConnected();\n        logger_1.default.debug('waitForCivicPassRefreshResponsePayload');\n        const result = new Promise((resolve) => {\n            const responsePayload = civicPass === null || civicPass === void 0 ? void 0 : civicPass.responsePayload;\n            const refreshPayload = responsePayload && responsePayload[types_1.CivicPassMessageAction.REFRESH];\n            logger_1.default.debug('Refresh payload...', {\n                refreshPayload,\n                refreshPayloadState: refreshPayload === undefined,\n            });\n            if (refreshPayload !== undefined) {\n                logger_1.default.debug('Refreshing token...');\n                resolve(refreshPayload);\n            }\n        });\n        return result;\n    }, [civicPass === null || civicPass === void 0 ? void 0 : civicPass.responsePayload, expectWalletConnected]);\n    /**\n     * When we have a token start check the next expiration so we can prompt the user to refresh\n     */\n    (0, react_1.useEffect)(() => {\n        if (gatewayStatus === types_1.GatewayStatus.ACTIVE || refreshTokenState === types_1.RefreshTokenState.COMPLETED) {\n            logger_1.default.debug('Start polling for the refresh interval');\n            checkForRefreshWithTimeout(wallet);\n        }\n    }, [gatewayStatus, refreshTokenState, wallet, renderIframe]);\n    /**\n     * Whenever the iFrame is rendered, clear the timeout\n     */\n    (0, react_1.useEffect)(() => {\n        if (renderIframe && refreshTimeoutId) {\n            clearTimeout(refreshTimeoutId);\n            dispatch({ type: 'refresh_clear_timeout' });\n        }\n    }, [renderIframe, refreshTimeoutId]);\n    /**\n     * Issuance Flows ----------------------------------------------------------------\n     */\n    /**\n     * poll until a gatekeeper record is found, once active check the chain for a token\n     * then dispatch a tokenChange event that will result in the token getting saved to state\n     * start token refresh polling once a valid token is set\n     */\n    const waitForOnChainToken = (0, react_1.useCallback)(async () => {\n        if (wallet) {\n            logger_1.default.debug('waitForOnChainToken');\n            const actionCreator = (0, actionCreator_1.gatewayTokenActionCreator)({\n                wallet,\n                chainImplementation,\n                gatekeeperClient,\n                dispatch,\n                networkConfig,\n            });\n            await actionCreator.waitForGatewayToken();\n        }\n        return null;\n    }, [gatekeeperEndpoint, gatekeeperClient, expectWalletConnected]);\n    /**\n     * wait until a presentation request id has been emitted by the CivicPass iframe\n     * then resolve the promise\n     */\n    const waitForCivicPassIssuanceResponsePayload = (0, react_1.useCallback)(() => {\n        expectWalletConnected();\n        logger_1.default.debug('waitForCivicPassIssuanceResponsePayload');\n        const result = new Promise((resolve) => {\n            const responsePayload = civicPass === null || civicPass === void 0 ? void 0 : civicPass.responsePayload;\n            const issuancePayload = responsePayload && responsePayload[types_1.CivicPassMessageAction.ISSUANCE];\n            logger_1.default.debug('Issuance payload...', issuancePayload);\n            if (issuancePayload !== undefined) {\n                resolve(issuancePayload);\n            }\n        });\n        return result;\n    }, [civicPass === null || civicPass === void 0 ? void 0 : civicPass.responsePayload, expectWalletConnected]);\n    /**\n     * wait until the user has requested a gateway token before resolving the promise\n     */\n    const checkForRequiredProof = (0, react_1.useCallback)(async ({ requiresProofOfWalletOwnership, payload, }) => {\n        logger_1.default.debug('Checking for required proof', { requiresProofOfWalletOwnership, payload });\n        if (requiresProofOfWalletOwnership) {\n            const result = await waitForConfirmPOWO(payload).then(waitForPOWO);\n            return result;\n        }\n        return { payload };\n    }, [waitForConfirmPOWO, waitForPOWO]);\n    /**\n     * New token request flow:\n     * wait for the user to request a new token\n     * wait for the iframe to return a payload\n     * wait for the user to confirm they've read the proof of ownership dialogue\n     * wait for the user to provide proof of ownership\n     * wait for a call to the gatekeeper to request a new token issuance\n     * wait for a gatekeeper record to be created\n     * once this flow is complete a new Gatekeeper token should be available and set in state\n     */\n    (0, react_1.useEffect)(() => {\n        if (!ownerSigns) {\n            waitForCivicPassIssuanceResponsePayload()\n                .then(checkForRequiredProof)\n                .then(waitForGatekeeperIssuanceRequest)\n                .then(waitForOnChainToken)\n                .then(() => checkForRefreshWithTimeout(wallet))\n                .catch((error) => {\n                dispatch({ type: 'civicPass_issuance_failure' });\n                logger_1.default.error('ERROR newTokenRequestFlow', error);\n            });\n        }\n    }, [\n        waitForCivicPassIssuanceResponsePayload,\n        checkForRequiredProof,\n        waitForGatekeeperIssuanceRequest,\n        waitForOnChainToken,\n        ownerSigns,\n    ]);\n    (0, react_1.useEffect)(() => {\n        if (ownerSigns) {\n            waitForCivicPassIssuanceResponsePayload()\n                .then(waitForGatekeeperIssuanceRequest)\n                .then(waitForHandleTransaction)\n                .then(waitForOnChainToken)\n                .then(() => checkForRefreshWithTimeout(wallet))\n                .catch((error) => {\n                dispatch({ type: 'civicPass_issuance_failure' });\n                logger_1.default.error('ERROR newTokenRequestFlow', error);\n            });\n        }\n    }, [\n        waitForCivicPassIssuanceResponsePayload,\n        checkForRequiredProof,\n        waitForGatekeeperIssuanceRequest,\n        waitForOnChainToken,\n        ownerSigns,\n    ]);\n    /**\n     * Refresh start flow:\n     * Triggered when we have a refreshResponse payload\n     * wait refresh to be triggered from the iFrame\n     * wait for the iframe to return a payload\n     * wait for the user to confirm they've read the proof of ownership dialogue\n     * wait for the user to provide proof of ownership\n     * wait for a call to the gatekeeper to refresh the token\n     * check if token is expired and timeout if token does not update within timeframe\n     */\n    (0, react_1.useEffect)(() => {\n        if (!ownerSigns) {\n            const useWallet = walletToRefresh || wallet;\n            waitForCivicPassRefreshResponsePayload()\n                .then(checkForRequiredProof)\n                .then(refreshToken(useWallet))\n                .then(waitForUnexpiredGatewayToken)\n                .catch((error) => {\n                logger_1.default.error('refreshFlow', error);\n                logger_1.default.error('refreshToken error', error);\n                dispatch({ type: 'refresh_failed' });\n            });\n        }\n    }, [civicPass === null || civicPass === void 0 ? void 0 : civicPass.responsePayload, checkForRequiredProof, ownerSigns]);\n    (0, react_1.useEffect)(() => {\n        if (ownerSigns) {\n            const useWallet = walletToRefresh || wallet;\n            waitForCivicPassRefreshResponsePayload()\n                .then(refreshToken(useWallet))\n                .then(waitForHandleTransaction)\n                .then(waitForUnexpiredGatewayToken)\n                .catch((error) => {\n                logger_1.default.error('refreshFlow', error);\n                logger_1.default.error('refreshToken error', error);\n                dispatch({ type: 'refresh_failed' });\n            });\n        }\n    }, [civicPass === null || civicPass === void 0 ? void 0 : civicPass.responsePayload, checkForRequiredProof, walletToRefresh, wallet, ownerSigns]);\n    /**\n     * Refresh complete flow:\n     * Triggered by token change event\n     * Check the refresh token state\n     * Check if token is unexpired and clear timeout if token is not expired\n     * Complete the refresh event and clear the refresh response payload\n     */\n    (0, react_1.useEffect)(() => {\n        const useWallet = walletToRefresh || wallet;\n        if (refreshTokenState === types_1.RefreshTokenState.WAIT_FOR_ON_CHAIN) {\n            waitForUnexpiredGatewayToken()\n                .then(() => checkForRefreshWithTimeout(useWallet))\n                .then(() => {\n                dispatch({ type: 'refresh_complete' });\n            })\n                .catch((error) => {\n                logger_1.default.error('refreshFlow', error);\n                logger_1.default.error('refreshToken error', error);\n                dispatch({ type: 'refresh_failed' });\n            });\n        }\n    }, [gatewayToken, refreshTokenState, walletToRefresh, wallet]);\n};\nexports.default = useOrchestration;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}